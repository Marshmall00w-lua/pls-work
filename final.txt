local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success or not WindUI then
    warn("‚ùå Failed to load WindUI")
    return
end

-- üåà Add all themes
themeNames = {
    "Ocean Blue","Forest Green","Minimal Light","Retro Purple","Sunset",
    "Neon Pulse","Steel Phantom","Vaporwave","Deep Sea","Sepia Warmth",
    "Monokai Dark","Solarized Light","Cherry Blossom","Charcoal Gold",
    "Icy Mint","Volcano","Amethyst","Pastel Dream","Coffee Shop","Cyberpunk Red"
}

-- Example: Adding all themes
themeColors = {
    ["Ocean Blue"] = {Accent="#0B5394", Dialog="#0A3D6B", Outline="#6DACEA", Text="#EBF5FF", Placeholder="#85AECF", Background="#051A2E", Button="#1C67A8", Icon="#A9D5FD"},
    ["Forest Green"] = {Accent="#1A5E2E", Dialog="#114220", Outline="#8AC79B", Text="#E9FCE9", Placeholder="#79A378", Background="#0A2B14", Button="#2B7A42", Icon="#B3E3C1"},
    ["Minimal Light"] = {Accent="#F3F4F6", Dialog="#FFFFFF", Outline="#4B5563", Text="#1F2937", Placeholder="#9CA3AF", Background="#F9FAFB", Button="#E5E7EB", Icon="#4B5563"},
    ["Retro Purple"] = {Accent="#7E22CE", Dialog="#4A148C", Outline="#F0ABFC", Text="#FDF4FF", Placeholder="#BC8FDD", Background="#2D0557", Button="#9333EA", Icon="#F0ABFC"},
    ["Sunset"] = {Accent="#FF8847", Dialog="#CC5500", Outline="#FFD9C0", Text="#FFF7F0", Placeholder="#FFC099", Background="#331A00", Button="#FF7043", Icon="#FFD9C0"},
    ["Neon Pulse"] = {Accent="#00FF00", Dialog="#111111", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#008800", Background="#000000", Button="#39FF14", Icon="#00FFFF"},
    ["Steel Phantom"] = {Accent="#404040", Dialog="#262626", Outline="#A3A3A3", Text="#D4D4D4", Placeholder="#737373", Background="#171717", Button="#525252", Icon="#A3A3A3"},
    ["Vaporwave"] = {Accent="#FF00FF", Dialog="#1B001B", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#FF69FF", Background="#0A0014", Button="#E75480", Icon="#00FFFF"},
    ["Deep Sea"] = {Accent="#008B8B", Dialog="#005A5A", Outline="#80CBC4", Text="#E0FFFF", Placeholder="#4DB6AC", Background="#003636", Button="#00A3A3", Icon="#80CBC4"},
    ["Sepia Warmth"] = {Accent="#7B3F00", Dialog="#5C3200", Outline="#D2B48C", Text="#F5E8D6", Placeholder="#A98F70", Background="#3D291F", Button="#9D5B18", Icon="#D2B48C"},
    ["Monokai Dark"] = {Accent="#F92672", Dialog="#272822", Outline="#66D9EF", Text="#F8F8F2", Placeholder="#75715E", Background="#1C1E1A", Button="#A6E22E", Icon="#66D9EF"},
    ["Solarized Light"] = {Accent="#268BD2", Dialog="#FDF6E3", Outline="#93A1A1", Text="#586E75", Placeholder="#839496", Background="#EEE8D5", Button="#B58900", Icon="#268BD2"},
    ["Cherry Blossom"] = {Accent="#F9BCCB", Dialog="#FFFAFD", Outline="#D96985", Text="#4A1429", Placeholder="#C397A3", Background="#FFF7F9", Button="#E68A9F", Icon="#D96985"},
    ["Charcoal Gold"] = {Accent="#FFD700", Dialog="#2C2C2C", Outline="#C0C0C0", Text="#F5F5F5", Placeholder="#6E6E6E", Background="#1D1D1D", Button="#B8860B", Icon="#FFD700"},
    ["Icy Mint"] = {Accent="#40E0D0", Dialog="#F0FFFF", Outline="#81D4FA", Text="#004D40", Placeholder="#B2DFDB", Background="#E0FFFF", Button="#80CBC4", Icon="#40E0D0"},
    ["Volcano"] = {Accent="#B22222", Dialog="#1C1C1C", Outline="#FF6347", Text="#EBEBEB", Placeholder="#704747", Background="#0A0A0A", Button="#FF4500", Icon="#FF6347"},
    ["Amethyst"] = {Accent="#9966CC", Dialog="#36284C", Outline="#CCFF66", Text="#EDE9F2", Placeholder="#8A72A4", Background="#221A33", Button="#7A52AA", Icon="#CCFF66"},
    ["Pastel Dream"] = {Accent="#FFB3BA", Dialog="#FAF3E0", Outline="#BAE1FF", Text="#333333", Placeholder="#C1B4A5", Background="#FFFFFF", Button="#BAE1FF", Icon="#FFB3BA"},
    ["Coffee Shop"] = {Accent="#795548", Dialog="#F5F5DC", Outline="#A1887F", Text="#3E2723", Placeholder="#BCB0A4", Background="#FFF8E1", Button="#D7CCC8", Icon="#795548"},
    ["Cyberpunk Red"] = {Accent="#FF3333", Dialog="#080008", Outline="#33FFFF", Text="#FDFDFD", Placeholder="#771111", Background="#000000", Button="#CC0000", Icon="#33FFFF"}
}

-- Add all themes to WindUI
for name, colors in pairs(themeColors) do
    WindUI:AddTheme({
        Name = name,
        Accent = Color3.fromHex(colors.Accent),
        Dialog = Color3.fromHex(colors.Dialog),
        Outline = Color3.fromHex(colors.Outline),
        Text = Color3.fromHex(colors.Text),
        Placeholder = Color3.fromHex(colors.Placeholder),
        Background = Color3.fromHex(colors.Background),
        Button = Color3.fromHex(colors.Button),
        Icon = Color3.fromHex(colors.Icon)
    })
end

WindUI:SetTheme("Volcano") -- default

local function GradientText(text, color1, color2)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = color1.R + (color2.R - color1.R) * t
        local g = color1.G + (color2.G - color1.G) * t
        local b = color1.B + (color2.B - color1.B) * t
        local hex = string.format("#%02X%02X%02X", r * 255, g * 255, b * 255)
        result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
    end
    return result
end

local Window = WindUI:CreateWindow({
    Title = "RyZen Hub",
    Icon = "rbxassetid://84501312005643",
    IconThemed = true,
    Author = "By @mallo",
    Size = UDim2.fromOffset(580, 460),
    Resizable = true,
    Transparent = true,
    User = {
        Enabled = true,
        Anonymous = False,
        Callback = function()
            print("clicked")
        end,
    },
})

Window:Tag({
    Title = "99 nights",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, -- from 0 to 13
})

Window:Tag({
    Title = "v1.0-Beta",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, -- from 0 to 13
})

Window:SetIconSize(50) -- default is 20

Window:EditOpenButton({
    Title = "RyZen Hub",
    Icon = "rbxassetid://84501312005643",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new( -- gradient
        Color3.fromHex("ADD8E6"), 
        Color3.fromHex("00008B")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

Window:DisableTopbarButtons({ "Close" })

local Info = Window:Tab({Title = "Information", Icon = "info" })

local InviteCode = "KG9ADqwT9Q" -- change to your discord invite
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response
local ErrorMessage = nil

xpcall(function()
    Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    }).Body)
end, function(err)
    warn("err fetching discord info: " .. tostring(err))
    ErrorMessage = tostring(err)
    Response = nil
end)

if Response and Response.guild then
    local ParagraphConfig = {
        Title = Response.guild.name,
        Desc =
            ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(Response.approximate_member_count) ..
            '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(Response.approximate_presence_count)
        ,
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256",
        ImageSize = 42,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Discord Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Info",
                Callback = function()
                    xpcall(function()
                        local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                            Url = DiscordAPI,
                            Method = "GET",
                        }).Body)
                        
                        if UpdatedResponse and UpdatedResponse.guild then
                            DiscordInfo:SetDesc(
                                ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(UpdatedResponse.approximate_member_count) ..
                                '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(UpdatedResponse.approximate_presence_count)
                            )
                        end
                    end, function(err)
                        warn("err updating discord info: " .. tostring(err))
                    end)
                end
            }
        }
    }
    
    if Response.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=256"
        ParagraphConfig.ThumbnailSize = 80
    end
    
    local DiscordInfo = Info:Paragraph(ParagraphConfig)
else
    Info:Paragraph({
        Title = "Error when receiving information about the Discord server",
        Desc = ErrorMessage or "Unknown error occurred",
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

-- üìò Game Information Box (like ‚ÄúBubble Gum Simulator INFINITY‚Äù)
local GameInfo = Info:Paragraph({
    Title = GradientText("PanScript", Color3.fromRGB(173, 216, 230), Color3.fromRGB(0, 0, 139)),
    Desc = "Script made by @mallo",
    Color = "White",
})

local Paragraph = Info:Paragraph({
    Title = "Version Beta!",
    Desc = "More features Coming Soon! If you encounted some bugs join our discord to report it!",
    Color = "White"
})

Window:Divider()

-- üè† Main Tab
local MainTab = Window:Tab({
    Title = "Main",
    Icon = "house",
})

ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait until RemoteEvents folder exists
remoteFolder = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not remoteFolder then
    warn("‚ùå RemoteEvents folder not found in ReplicatedStorage.")
    return
end

-- Wait until DamagePlayer event exists
DamageEvent = remoteFolder:WaitForChild("DamagePlayer", 10)
if not DamageEvent then
    warn("‚ùå DamagePlayer event not found in RemoteEvents.")
    return
end

-- God Mode Button
MainTab:Button({
    Title = "God Mode",
    Desc = "Become unkillable instantly",
    Callback = function()
        DamageEvent:FireServer(-math.huge)
        WindUI:Notify({
            Title = "God Mode",
            Content = "You're now invincible!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643",
        })
    end
})

MainTab:Section({
    Icon = "shield",
    Title = "Kill Aura",
})

-- Ensure Settings exist
if type(_G.Settings) ~= "table" then _G.Settings = {} end
if type(_G.Settings.Main) ~= "table" then _G.Settings.Main = {} end

-- Default values
_G.Settings.Main["Kill Aura"] = _G.Settings.Main["Kill Aura"] or false
_G.Settings.Main["Kill Aura Targets"] = _G.Settings.Main["Kill Aura Targets"] or {"All"}
_G.Settings.Main["Kill Aura Range"] = _G.Settings.Main["Kill Aura Range"] or 100

-- Kill Aura Targets
killAuraTargets = {
    "All","Polar Bear","Arctic Fox","Mammoth","Cultist","Crossbow Cultist",
    "Cultist King","Scorpion","Wolf","Alpha Wolf","Bear","Bunny","Frog",
    "Hellephant","Meteor Crab","Juggernaut King","Alien"
}

MainTab:Dropdown({
    Flag = "KillAura",
    Title = "Kill Aura Targets",
    Description = "Select enemies to Target",
    Values = killAuraTargets,
    Value = {"All"},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedTargets)
        _G.Settings.Main["Kill Aura Targets"] = selectedTargets
    end
})

-- Services
Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
ReplicatedStorage = game:GetService("ReplicatedStorage")
player = Players.LocalPlayer

-- Client module
client_ok, Client = pcall(function()
    return require(player:WaitForChild("PlayerScripts"):WaitForChild("Client"))
end)

-- Tools
toolsDamageIDs = {
    ["Old Axe"] = "_1",
    ["Good Axe"] = "_1",
    ["Strong Axe"] = "_1",
    ["Chainsaw"] = "_1",
    ["Laser Sword"] = "_1"
}

function getToolAndDamageID()
    inv = player:FindFirstChild("Inventory")
    if not inv then return nil, nil end
    for toolName, suffix in pairs(toolsDamageIDs) do
        local tool = inv:FindFirstChild(toolName)
        if tool then return tool, suffix end
    end
    return nil, nil
end

function findHRP(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("UpperTorso")
end

function invokeToolDamage(targetObj, toolObj, damageID, charCFrame)
    if client_ok and Client and Client.Events and Client.Events.ToolDamageObject then
        local ok, res = pcall(function()
            return Client.Events.ToolDamageObject:InvokeServer(targetObj, toolObj, damageID, charCFrame)
        end)
        if ok then return res end
    end
    fallback = ReplicatedStorage:FindFirstChild("RemoteEvents") and ReplicatedStorage.RemoteEvents:FindFirstChild("ToolDamageObject")
    if fallback and fallback:IsA("RemoteFunction") then
        ok, res = pcall(function()
            return fallback:InvokeServer(targetObj, toolObj, damageID, charCFrame)
        end)
        if ok then return res end
    end
    return nil
end

hitCounter = 1

-- Kill Aura Loop
spawn(function()
    while true do
        wait(0.18)
        if _G.Settings.Main["Kill Aura"] and player and player.Character then
            char = player.Character
            hrp = findHRP(char)
            tool, suffix = getToolAndDamageID()
            if hrp and tool and suffix then

                targets = _G.Settings.Main["Kill Aura Targets"] or {"All"}
                attackAll = false
                for i, t in pairs(targets) do
                    if t == "All" then attackAll = true end
                end
                auraRange = tonumber(_G.Settings.Main["Kill Aura Range"]) or 100

                charactersFolder = Workspace:FindFirstChild("Characters") or Workspace
                children = charactersFolder:GetChildren()
                for i = 1, #children do
                    enemy = children[i]
                    if enemy:IsA("Model") and enemy ~= char then
                        enemyHRP = findHRP(enemy)
                        if enemyHRP and enemy.Parent then
                            shouldAttack = attackAll
                            if not attackAll then
                                for j, t in pairs(targets) do
                                    if string.lower(t) == string.lower(enemy.Name) then
                                        shouldAttack = true
                                        break
                                    end
                                end
                            end

                            if shouldAttack then
                                distance = (enemyHRP.Position - hrp.Position).Magnitude
                                if distance <= auraRange then
                                    for k = 1, 10 do
                                        if not _G.Settings.Main["Kill Aura"] or not enemy or not enemy.Parent then break end
                                        damageID = tostring(hitCounter) .. suffix
                                        ok, err = pcall(function()
                                            invokeToolDamage(enemy, tool, damageID, hrp.CFrame)
                                        end)
                                        if not ok then
                                            warn("Kill Aura hit failed:", err)
                                        end
                                        hitCounter = hitCounter + 1
                                        wait(0.01)
                                    end
                                end
                            end
                        end
                    end
                end

            end
        end
    end
end)

-- Kill Aura Range Circle
local showRange = false
local ringSegments = 36
local ringParts = {}
local ringFolder = workspace:FindFirstChild("KillAuraRange")
if not ringFolder then
    ringFolder = Instance.new("Folder")
    ringFolder.Name = "KillAuraRange"
    ringFolder.Parent = workspace
end

for i = 1, ringSegments do
    local part = Instance.new("Part")
    part.Size = Vector3.new(0.2, 0.2, 4)
    part.Anchored = true
    part.CanCollide = false
    part.CastShadow = false
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(255, 0, 0)
    part.Parent = ringFolder
    table.insert(ringParts, part)
end

local function updateCircle(pos, radius)
    for i = 1, #ringParts do
        local part = ringParts[i]
        local angle = (i / #ringParts) * math.pi * 2
        local x = math.cos(angle) * radius
        local z = math.sin(angle) * radius
        part.CFrame = CFrame.new(pos + Vector3.new(x, 0.5, z)) * CFrame.Angles(0, -angle, 0)
    end
end

spawn(function()
    while true do
        wait(0.1)
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            if showRange then
                updateCircle(char.HumanoidRootPart.Position, _G.Settings.Main["Kill Aura Range"])
            else
                for i = 1, #ringParts do
                    ringParts[i].Position = Vector3.new(0, -9999, 0)
                end
            end
        end
    end
end)

-- GUI Toggles
MainTab:Toggle({
    Flag = "KillAura",
    Title = "Kill Aura",
    Desc = "Kill Enemies easily",
    Callback = function(state)
        _G.Settings.Main["Kill Aura"] = state
    end
})

-- Slider & Toggle (unchanged)
MainTab:Slider({
    Flag = "KillAura",
    Title = "Kill Aura Range",
    Desc = "Adjust the range for Kill Aura",
    Step = 1,
    Value = {
        Min = 5,
        Max = 50,
        Default = _G.Settings.Main["Kill Aura Range"],
    },
    Callback = function(value)
        _G.Settings.Main["Kill Aura Range"] = tonumber(value)
    end
})

MainTab:Toggle({
    Flag = "KillAura",
    Title = "Show Kill Aura Range",
    Desc = "Display red circle for Kill Aura",
    Default = false,
    Callback = function(state)
        showRange = state
    end
})


MainTab:Section({
    Icon = "cog",
    Title = "Auto Tame",
})

-- ‚öôÔ∏è Core Services
Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer

-- ü™∂ Auto-Tame Function (resize both SuccessArea & TimingBar)
local function autoTameResize()
    local gui = player:WaitForChild("PlayerGui"):WaitForChild("Interface"):WaitForChild("TamingFluteFrame")
    local timingBar = gui:WaitForChild("TimingBar")
    local successArea = timingBar:WaitForChild("SuccessArea")

    -- Expand SuccessArea and match TimingBar
    successArea.Size = UDim2.new(3, 1, 10.3, 10)
    successArea.Position = UDim2.new(0.5, 0, 0.5, 0)
    timingBar.Size = successArea.Size
    timingBar.Position = successArea.Position
end

-- üß≠ UI Elements (WindUI / Fluent Style)
local Toggle = MainTab:Toggle({
    Flag = "AutoTame",
    Title = "Auto Tame",
    Desc = "Automatically completes taming minigame",
    Icon = "target",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        _G.AutoTameEnabled = state
        if state then
            -- Listen for minigame visibility
            local gui = player:WaitForChild("PlayerGui"):WaitForChild("Interface"):WaitForChild("TamingFluteFrame")
            gui:GetPropertyChangedSignal("Visible"):Connect(function()
                if _G.AutoTameEnabled and gui.Visible then
                    autoTameResize()
                end
            end)
        end
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Helper: get Old Taming Flute from inventory
local function getFlute()
    return player:FindFirstChild("Inventory") and player.Inventory:FindFirstChild("Old Taming Flute")
end

-- Helper: get Old Taming Flute from workspace
local function getFluteFromWorkspace()
    local itemFlute = workspace:FindFirstChild("Items") and workspace.Items:FindFirstChild("Old Taming Flute")
    if not itemFlute then
        for _, child in ipairs(workspace.Items:GetChildren()) do
            if child:FindFirstChild("Main") then
                itemFlute = child.Main
                break
            end
        end
    end
    return itemFlute
end

-- Function to grab the flute
local function grabFlute()
    local flute = getFlute()
    if not flute then
        local itemFlute = getFluteFromWorkspace()
        if itemFlute then
            pcall(function()
                ReplicatedStorage.RemoteEvents.RequestHotbarItem:InvokeServer(itemFlute)
            end)
        else
            -- WindUI notification when no flute found
            pcall(function()
                WindUI:Notify({
                    Title = "Grab Flute",
                    Content = "No Old Taming Flute detected!",
                    Duration = 3,
                    Icon = "bird",
                })
            end)
        end
    else
        -- Already have flute notification
        pcall(function()
            WindUI:Notify({
                Title = "Grab Flute",
                Content = "You already have the flute!",
                Duration = 2,
                Icon = "rbxassetid://84501312005643",
            })
        end)
    end
end

-- MainTab button to manually grab flute
MainTab:Button({
    Title = "Grab Flute Now",
    Callback = grabFlute
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local healEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

-- üîß Variables
local autoHealEnabled = false
local healThreshold = 50
local cooldown = false

MainTab:Section({
    Icon = "shield",
    Title = "Auto Heal",
})

MainTab:Toggle({
    Flag = "Auto heal",
    Title = "Auto Heal (bandage)",
    Default = false,
    Callback = function(state)
        autoHealEnabled = state
    end
})

local Slider = MainTab:Slider({
    Flag = "Auto heal",
    Title = "Heal When Below",
    Desc = "Auto heal when HP drops below this value",
    Step = 1,
    Value = {
        Min = 20,
        Max = 100,
        Default = 70,
    },
    Callback = function(value)
        print("Slider value:", value)
    end
})

-- üîÅ Heal loop
task.spawn(function()
    while task.wait(0.5) do
        if autoHealEnabled and not cooldown then
            local char = player.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")

            if humanoid and humanoid.Health > 0 and humanoid.Health <= healThreshold then
                local inv = player:FindFirstChild("Inventory")
                local bandage = inv and inv:FindFirstChild("Bandage")

                if bandage then
                    healEvent:InvokeServer(bandage)
                    WindUI:Notify({
                        Title = "Auto Heal",
                        Content = "Used Bandage at " .. math.floor(humanoid.Health) .. " HP!",
                        Duration = 3,
                        Icon = "rbxassetid://84501312005643",
                    })
                    cooldown = true
                    task.wait(5)
                    cooldown = false
                else
                    WindUI:Notify({
                        Title = "Auto Heal",
                        Content = "No Bandage found in inventory!",
                        Duration = 3,
                        Icon = "rbxassetid://84501312005643",
                    })
                    task.wait(3)
                end
            end
        end
    end
end)

local BringTab = Window:Tab({
    Title = "Bring Items",
    Icon = "package",
})

local Section = BringTab:Section({ 
    Title = "Settings",
    Icon = "cog",
})

-- Target selection
local BringTarget = "You"

BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Target",
    Values = {"You", "Campfire", "Workbench"},
    Value = BringTarget,
    Callback = function(selected)
        BringTarget = selected
        print(" Bring target set to:", BringTarget)
    end
})

-- Max per item variable
local MaxPerItem = 10 -- default

local Input = BringTab:Input({
    Flag = "BringItems",
    Title = "Max Per Item",
    Desc = "Enter how many of each item to bring",
    Value = tostring(MaxPerItem), -- show default value
    InputIcon = "bird",
    Type = "Input", -- single-line input
    Placeholder = "Enter number...",
    Callback = function(input)
        local num = tonumber(input)
        if num and num > 0 then
            MaxPerItem = num
            print("üéöÔ∏è MaxPerItem set to:", MaxPerItem)
        else
            warn("‚ö†Ô∏è Invalid number entered")
        end
    end
})

-- Selected items table
local SelectedItems = {}

-- Full items list with "All" option
local ItemsList = {
    "All", -- special option to select everything
    "Bolt", "Tyre", "Sheet Metal", "Old Radio", "Broken Fan",
    "Broken Microwave", "Washing Machine", "Old Car Engine",
    "UFO Scrap", "UFO Component", "UFO Junk", "Cultist Gem", "Gem of the Forest"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

local Section = BringTab:Section({ 
    Title = "Gears",
    Icon = "cog",
})

-- Selected item variable
local SelectedItem = "Bolt" -- default value

BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Gear",
    Values = ItemsList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedItems = {}
            for _, item in ipairs(ItemsList) do
                if item ~= "All" then
                    table.insert(SelectedItems, item)
                end
            end
        else
            SelectedItems = selected
        end
        print("üéØ Selected Items:", table.concat(SelectedItems, ", "))
    end
})

BringTab:Button({
    Title = "Bring Selected Items",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundItems = {} -- store missing items
        local broughtItemsCount = 0 -- total items brought

        for _, itemName in ipairs(SelectedItems) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtItemsCount = broughtItemsCount + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundItems, itemName)
            else
                print("Brought", broughtCount, itemName, "to", BringTarget)
            end
        end

        -- Notify missing items
        if WindUI and #notFoundItems > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find items",
                    Content = table.concat(notFoundItems, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify success
        if WindUI and broughtItemsCount > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Items Brought",
                    Content = "Successfully brought " .. broughtItemsCount .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Fuel",
    Icon = "flame",
})

-- Fuel List (with All)
local FuelList = {
    "All",
    "Corpse", "Sapling", "Alien", "Log", "Chair",
    "Coal", "Fuel Canister", "Oil Barrel", "Biofuel"
}

-- Selected fuel table
local SelectedFuel = {}

BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Fuel",
    Values = FuelList,
    Multi = true,
    Value = {},
    Callback = function(selected)
        if table.find(selected, "All") then
            SelectedFuel = {}
            for _, fuel in ipairs(FuelList) do
                if fuel ~= "All" then
                    table.insert(SelectedFuel, fuel)
                end
            end
        else
            SelectedFuel = selected
        end

        print("üî• Selected Fuel:", table.concat(SelectedFuel, ", "))
    end
})

BringTab:Button({
    Title = "Bring Selected Fuel",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 9.5, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundFuel = {}
        local broughtTotal = 0

        for _, fuelName in ipairs(SelectedFuel) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == fuelName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Drag ‚Üí Move ‚Üí Drop
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
broughtTotal = broughtTotal + 1
                                        
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundFuel, fuelName)
            else
                print("üî• Brought", broughtCount, fuelName, "to", BringTarget)
            end
        end

        -- Notify missing fuel
        if WindUI and #notFoundFuel > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Missing Fuel",
                    Content = table.concat(notFoundFuel, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify success
        if WindUI and broughtTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Fuel Delivered",
                    Content = "Successfully brought " .. broughtTotal .. " fuel item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Food & healing",
    Icon = "apple",
})

-- Selected food table
local SelectedFood = {}

-- Full food & healing list with "All" option
local FoodList = {
    "All", -- special option to select everything
    "Carrot", "Berry", "Morsel", "Steak", "Ribs",
    "Cooked Morsel", "Cooked Steak", "Cooked Ribs",
    "Bandage", "Medkit", "Chili"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Food dropdown
BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Food & Healing",
    Values = FoodList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedFood = {}
            for _, food in ipairs(FoodList) do
                if food ~= "All" then
                    table.insert(SelectedFood, food)
                end
            end
        else
            SelectedFood = selected
        end
        print("üéØ Selected Food:", table.concat(SelectedFood, ", "))
    end
})

-- Bring Food button
BringTab:Button({
    Title = "Bring Selected Food & Healing",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundFood = {} -- store missing items
        local broughtCountTotal = 0

        for _, foodName in ipairs(SelectedFood) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == foodName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtCountTotal = broughtCountTotal + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundFood, foodName)
            else
                print("‚úÖ Brought", broughtCount, foodName, "to", BringTarget)
            end
        end

        -- Notify missing food
        if WindUI and #notFoundFood > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find food",
                    Content = table.concat(notFoundFood, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtCountTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Food Brought",
                    Content = "Successfully brought " .. broughtCountTotal .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Weapons & ammo",
    Icon = "swords",
})

-- Selected weapons table
local SelectedWeapons = {}

-- Full weapons list with "All" option
local WeaponList = {
    "All", -- special option to select everything
    "Morning star", "Laser Sword", "Raygun", "Chainsaw", "Strong Axe",
    "Spear", "Good Axe", "Revolver", "Rifle", "Tactical Shotgun",
    "Revolver Ammo", "Rifle Ammo", "Alien Armour", "Leather Body",
    "Iron Body", "Thorn Body", "Riot Shield"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Weapon dropdown
BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Weapons",
    Values = WeaponList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedWeapons = {}
            for _, weapon in ipairs(WeaponList) do
                if weapon ~= "All" then
                    table.insert(SelectedWeapons, weapon)
                end
            end
        else
            SelectedWeapons = selected
        end
        print("üéØ Selected Weapons:", table.concat(SelectedWeapons, ", "))
    end
})

-- Bring Weapons button
BringTab:Button({
    Title = "Bring Selected Weapons",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundWeapons = {} -- store missing items
        local broughtCountTotal = 0

        for _, weaponName in ipairs(SelectedWeapons) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == weaponName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtCountTotal = broughtCountTotal + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundWeapons, weaponName)
            else
                print("‚úÖ Brought", broughtCount, weaponName, "to", BringTarget)
            end
        end

        -- Notify missing weapons
        if WindUI and #notFoundWeapons > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find weapons",
                    Content = table.concat(notFoundWeapons, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtCountTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Weapons Brought",
                    Content = "Successfully brought " .. broughtCountTotal .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Misc",
    Icon = "package",
})

-- Selected others table
local SelectedOthers = {}

-- Full others list with "All" option
local OthersList = {
    "All", -- special option to select everything
    "Sack", "Seed Box", "Chainsaw", "Old Flashlight", "Strong Flastlight",
    "Bunny Foot", "Wolf Pelt", "Bear Pelt", "Alpha Wolf Pet",
    "Artic Fox Pelt", "Polar Bear Pelt", "Mammoth Tusk"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Others dropdown
BringTab:Dropdown({
    Flag = "BringItems",
    Title = "Select Others",
    Values = OthersList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedOthers = {}
            for _, item in ipairs(OthersList) do
                if item ~= "All" then
                    table.insert(SelectedOthers, item)
                end
            end
        else
            SelectedOthers = selected
        end
        print("üéØ Selected Others:", table.concat(SelectedOthers, ", "))
    end
})

-- Bring Others button
BringTab:Button({
    Title = "Bring Selected Others",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundItems = {} -- store missing items
        local broughtItemsCount = 0 -- total items brought

        for _, itemName in ipairs(SelectedOthers) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtItemsCount = broughtItemsCount + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundItems, itemName)
            else
                print("‚úÖ Brought", broughtCount, itemName, "to", BringTarget)
            end
        end

        -- Notify missing items
        if WindUI and #notFoundItems > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find items",
                    Content = table.concat(notFoundItems, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtItemsCount > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Items Brought",
                    Content = "Successfully brought " .. broughtItemsCount .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local AutoTab = Window:Tab({
    Title = "Auto",
    Icon = "play",
})

local Section = AutoTab:Section({ 
    Title = "Lost Child",
    Icon = "baby",
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer

-- Campfire CFrame (teleport slightly higher)
local CampfireCFrame = CFrame.new(4.95910645e-05, 9.5, -7.62939453e-06)

-- Sack types
local Sacks = {
    ["Old Sack"] = true,
    ["Good Sack"] = true,
    ["Giant Sack"] = true,
}

-- Map child types to exact model names
local LostChildMap = {
    Dino = "Lost Child",
    Kraken = "Lost Child2",
    Squid = "Lost Child3",
    Koala = "Lost Child4"
}

local LostChildOptions = {"Dino", "Koala", "Kraken", "Squid"}
local SelectedChildren = {}
local CollectedChildren = {} -- track already collected
local PICKUP_DELAY = 1.5

-- GUI Dropdown
local Dropdown = Section:Dropdown({
    Flag = "AutoTab",
    Title = "Select Lost Child(s)",
    Desc = "Choose which child(s) to auto pick up",
    Values = LostChildOptions,
    Value = {LostChildOptions[1]},
    Multi = true,
    AllowNone = false,
    Callback = function(option)
        SelectedChildren = option
        print("Selected children: " .. HttpService:JSONEncode(option))
    end
})

-- Check if child is already in ItemBag
local function IsChildInInventory(childType)
    local modelName = LostChildMap[childType]
    local bag = LocalPlayer:FindFirstChild("ItemBag")
    if not bag then return false end
    local category = bag:FindFirstChild(modelName)
    if category and category:FindFirstChild(childType) then
        return true
    end
    return false
end

-- Teleport, pick up, return
local function TeleportAndPickup(childType)
    if IsChildInInventory(childType) then
        CollectedChildren[childType] = true
        WindUI:Notify({
            Title = "Already Found!",
            Content = childType .. " is already in your inventory!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643"
        })
        return
    end

    local Target = nil
    local modelName = LostChildMap[childType]

    for i = 1, 50 do
        Target = Workspace.Characters:FindFirstChild(modelName)
        if Target then break end
        task.wait(0.2)
    end

    if Target then
        local tpCFrame = Target.PrimaryPart and (Target.PrimaryPart.CFrame + Vector3.new(0, 3, 0)) or (Target:GetModelCFrame() + Vector3.new(0, 3, 0))
        LocalPlayer.Character:SetPrimaryPartCFrame(tpCFrame)
        task.wait(0.3)

        local SackName = nil
        for sack, _ in pairs(Sacks) do
            if LocalPlayer.Inventory:FindFirstChild(sack) then
                SackName = sack
                break
            end
        end

        if SackName then
            task.wait(PICKUP_DELAY)
            local success, _ = pcall(function()
                ReplicatedStorage.RemoteEvents.RequestBagStoreItem:InvokeServer(
                    LocalPlayer.Inventory[SackName],
                    Target
                )
            end)

            task.wait(0.8)

            if IsChildInInventory(childType) then
                CollectedChildren[childType] = true
                WindUI:Notify({
                    Title = "Success",
                    Content = "Picked up " .. childType .. "!",
                    Duration = 3,
                    Icon = "rbxassetid://84501312005643"
                })
            else
                CollectedChildren[childType] = false
                WindUI:Notify({
                    Title = "Failed",
                    Content = "Pickup failed for " .. childType .. "!",
                    Duration = 3,
                    Icon = "rbxassetid://84501312005643"
                })
            end

            LocalPlayer.Character:SetPrimaryPartCFrame(CampfireCFrame + Vector3.new(0, 2, 0))
        else
            WindUI:Notify({
                Title = "Error",
                Content = "No sack found!",
                Duration = 3,
                Icon = "rbxassetid://84501312005643"
            })
        end
    else
        WindUI:Notify({
            Title = "Not Found",
            Content = childType .. " Child not spawned yet!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643"
        })
    end
end

-- Helper to check if child should be skipped
local function ShouldSkipPickup(childType)
    return CollectedChildren[childType] or IsChildInInventory(childType)
end

-- Auto Pickup Toggle
local AutoPickupEnabled = false

local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Auto Pick Up",
    Desc = "Auto pick up selected Lost Child",
    Icon = "bird",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        AutoPickupEnabled = state
        print("Auto Pick Up Toggle: " .. tostring(state))

        if state then
            spawn(function()
                while AutoPickupEnabled do
                    local allCollected = true

                    for _, childName in pairs(SelectedChildren) do
                        if ShouldSkipPickup(childName) then
                            CollectedChildren[childName] = true
                        else
                            allCollected = false
                            TeleportAndPickup(childName)
                            task.wait(0.5)
                        end
                    end

                    if allCollected then
                        WindUI:Notify({
                            Title = "All Collected",
                            Content = "You have found the selected children!",
                            Duration = 5,
                            Icon = "rbxassetid://84501312005643"
                        })
                        AutoPickupEnabled = false
                        break
                    end

                    task.wait(1)
                end
            end)
        end
    end
})

local Section = AutoTab:Section({ 
    Title = "Auto Sapling",
    Icon = "tree-deciduous", 
})

-- Auto Sapling System
-- Script generated by TurtleSpy, made by Intrer#0421
-- Optimized version: smooth, fast, border-only square, safe planting

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

-- Remote event functions
local function startDrag(item)
    if item and item.Parent then
        pcall(function() remoteEvents.RequestStartDraggingItem:FireServer(item) end)
        return true
    end
    return false
end

local function plantItem(item, vec)
    if item and item.Parent then
        local success, err = pcall(function() remoteEvents.RequestPlantItem:InvokeServer(item, vec) end)
        return success, err
    end
    return false, "item missing"
end

local function stopDrag(item)
    if item and item.Parent then
        pcall(function() remoteEvents.StopDraggingItem:FireServer(item) end)
        return true
    end
    return false
end

-- Config
local campfirePos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
local itemsFolder = Workspace:WaitForChild("Items")
local plantDelay = 0.1 -- faster but smooth
local findSaplingTimeout = 3 -- skip if not found quickly

-- UI state
local placementMode = "Circle"
local saplingCount = 8
local saplingDistance = 30
local autoPlant = false
local showBlueprint = false
local isPlanting = false

-- Blueprint visuals
-- Blueprint folder
local blueprintFolder = Workspace:FindFirstChild("AutoSaplingBlueprints")
if not blueprintFolder then
    blueprintFolder = Instance.new("Folder")
    blueprintFolder.Name = "AutoSaplingBlueprints"
    blueprintFolder.Parent = Workspace
end

-- Clear existing blueprint parts
local function clearBlueprints()
    for _, c in ipairs(blueprintFolder:GetChildren()) do
        if c:IsA("BasePart") then
            c:Destroy()
        end
    end
end

-- Create a single blueprint part (only if showBlueprint is true)
local function createBlueprintPart(pos, idx)
    if not showBlueprint then return nil end
    local p = Instance.new("Part")
    p.Name = "Blueprint_"..idx
    p.Size = Vector3.new(1, 0.2, 1)
    p.Anchored = true
    p.CanCollide = false
    p.Transparency = 0.45
    p.Material = Enum.Material.Neon
    p.CFrame = CFrame.new(pos + Vector3.new(0, 0.1, 0))
    p.Parent = blueprintFolder
    return p
end

-- Generate positions (circle or square border)
local function generatePositions(mode, count, distance, center)
    local positions = {}

    if mode == "Circle" then
        for i = 1, count do
            local angle = (2 * math.pi) * ((i-1)/count)
            local x = center.X + math.cos(angle) * distance
            local z = center.Z + math.sin(angle) * distance
            table.insert(positions, Vector3.new(x, center.Y, z))
        end
    else -- Square (border only)
        local side = math.ceil(math.sqrt(count))
        local half = (side - 1) / 2
        local placed = 0
        for row = 0, side - 1 do
            for col = 0, side - 1 do
                if placed >= count then break end
                if row == 0 or row == side-1 or col == 0 or col == side-1 then
                    local x = center.X + (col - half) * distance
                    local z = center.Z + (row - half) * distance
                    table.insert(positions, Vector3.new(x, center.Y, z))
                    placed = placed + 1
                end
            end
        end
    end

    return positions
end

-- Find nearest sapling not reserved
local function findNearestSapling(targetPos, reserved)
    reserved = reserved or {}
    local best, bestDist
    for _, item in ipairs(itemsFolder:GetChildren()) do
        if item:IsA("Model") and item.Name == "Sapling" and not reserved[item] then
            local primary = item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
            if primary and primary.Position then
                local d = (primary.Position - targetPos).Magnitude
                if not bestDist or d < bestDist then
                    bestDist = d
                    best = item
                end
            end
        end
    end
    return best
end

-- Planting loop
local function plantPositions(positions)
    if isPlanting then return end -- prevent overlap
    isPlanting = true
    local reserved = {}
    for idx, pos in ipairs(positions) do
        local sapling = findNearestSapling(pos, reserved)
        local t0 = tick()
        while not sapling and tick() - t0 < findSaplingTimeout do
            wait(0.15)
            sapling = findNearestSapling(pos, reserved)
        end
        if sapling then
    reserved[sapling] = true
                    end

        startDrag(sapling)
        wait(plantDelay)
        plantItem(sapling, pos)
        wait(plantDelay)
        if sapling and sapling.Parent then stopDrag(sapling) end
        wait(0.1)
    end
    isPlanting = false
end

-- Update blueprint & optionally auto plant
local function updateBlueprint()
    clearBlueprints()
    local positions = generatePositions(placementMode, saplingCount, saplingDistance, campfirePos)
    if showBlueprint then
        for i, pos in ipairs(positions) do
            createBlueprintPart(pos, i)
        end
    end
    if autoPlant then
        spawn(function() plantPositions(positions) end)
    end
end

-- UI integration
local Dropdown = Section:Dropdown({
    Flag = "AutoTab",
    Title = "Sapling Placement Mode",
    Desc = "Circle or Square",
    Values = {"Circle","Square"},
    Default = placementMode,
    Callback = function(value)
        placementMode = value
        updateBlueprint()
    end
})

local Input = Section:Input({
    Title = "Sapling Count",
    Desc = "Number of saplings",
    Placeholder = tostring(saplingCount),
    Callback = function(text)
        local n = tonumber(text)
        if n and n > 0 then
            saplingCount = math.floor(n)
            updateBlueprint()
        end
    end
})

local Slider = Section:Slider({
    Flag = "AutoTab",
    Title = "Sapling Distance",
    Desc = "Spacing between saplings",
    Step = 0.5,
    Value = {Min=1, Max=100, Default=saplingDistance},
    Callback = function(value)
        saplingDistance = value
        updateBlueprint()
    end
})

local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Show Blueprint",
    Desc = "Show placement blueprint",
    Value = showBlueprint,
    Callback = function(state)
        showBlueprint = state
        updateBlueprint()
    end
})

local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Auto Plant Saplings",
    Desc = "Automatically plant saplings (according to blueprint)",
    Value = autoPlant,
    Callback = function(state)
        autoPlant = state
        updateBlueprint()
    end
})

-- Continuous AutoPlant loop
spawn(function()
    while true do
        wait(0.5) -- small throttle
        if autoPlant and not isPlanting then
            local positions = generatePositions(placementMode, saplingCount, saplingDistance, campfirePos)
            plantPositions(positions)
        end
    end
end)

-- Initial blueprint
updateBlueprint()
print("Auto Sapling optimized script loaded.")

local Section = AutoTab:Section({ 
    Title = "auto chest",
    Icon = "package-open", 
})

-- CATEGORY MODE: Collect chests by category (Option C)
-- Expects: Tab (UI), RemoteEvents in ReplicatedStorage with:
--   RequestStartDraggingItem, StopDraggingItem, RequestOpenItemChest

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
LocalPlayer.CharacterAdded:Connect(function() 
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

-- CAMPFIRE (edit if needed)
local campfirePos = Vector3.new(4.95910645e-05, 9.5, -7.62939453e-06)

-- CONFIG
local collectRadius = 10
local dragDelay = 0.10
local returnDelay = 0.15

-- NOTIFY helper
local function notify(title, text, duration)
    duration = duration or 3
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration
        })
    end)
end

-- safe remote fire (varargs captured)
local RemoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
local function safeFire(remoteName, ...)
    if not RemoteEvents then return false end
    local r = RemoteEvents:FindFirstChild(remoteName)
    if r and r:IsA("RemoteEvent") then
        local args = {...}
        local ok, err = pcall(function() r:FireServer(unpack(args)) end)
        if not ok then
            warn("RemoteEvent '"..tostring(remoteName).."' failed:", err)
            return false
        end
        return true
    end
    warn("RemoteEvent '"..tostring(remoteName).."' not found")
    return false
end

-- Helper: basic chest test (kept for safety)
local function isChestModel(m)
    return m and m:IsA("Model") and m.PrimaryPart and string.find(string.lower(m.Name), "chest")
end

--------------------------------------------------------------------------------
-- --------------------- Configure categories & keywords ----------------------
-- Each category has a display name (shown in dropdown) and a list of keywords
-- the script will match chest instances whose name contains any keyword.
--------------------------------------------------------------------------------
local categories = {
    { display = "Halloween Chests", keywords = { "halloween chest", "halloween" } },
    { display = "Item Chests",      keywords = { "item chest", "item chest" } },
    { display = "Volcanic Chests",  keywords = { "volcanic", "volcanic chest" } },
    { display = "Alien chest",  keywords = { "Alien", "AlienChest" } },
}
--------------------------------------------------------------------------------

-- Build dropdown values (display names)
local categoryNames = {}
for _, cat in ipairs(categories) do
    table.insert(categoryNames, cat.display)
end

-- Dropdown: categories (created once)
local selectedCategory = categoryNames[1]
local Dropdown = Section:Dropdown({
    Flag = "AutoTab",
    Title = "Select Category",
    Desc = "Choose chest category to collect",
    Values = categoryNames,
    Value = selectedCategory,
    Callback = function(option) selectedCategory = option end
})

-- Player lock/unlock
local function lockPlayer(state)
    local hum = Character and Character:FindFirstChildOfClass("Humanoid")
    if hum then
        if state then
            hum.WalkSpeed = 0
            hum.JumpPower = 0
        else
            hum.WalkSpeed = 16
            hum.JumpPower = 50
        end
    end
end

-- ESP system: one gui per chest Instance
local chestESPGui = {} -- [Instance] = {Highlight=hl, Gui=gui, Label=label}
local function createESPForChest(chest)
    if not chest or not chest.PrimaryPart or chestESPGui[chest] then return end
    local hl = Instance.new("Highlight")
    hl.Name = "ChestHighlight"
    hl.Adornee = chest
    hl.Parent = chest
    hl.FillColor = Color3.new(1,1,1)
    hl.FillTransparency = 0.8
    hl.OutlineColor = Color3.new(1,1,1)
    hl.OutlineTransparency = 0

    local gui = Instance.new("BillboardGui")
    gui.Name = "ChestText"
    gui.Size = UDim2.new(0, 140, 0, 20)
    gui.AlwaysOnTop = true
    gui.Adornee = chest.PrimaryPart
    gui.Parent = chest

    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.BackgroundTransparency = 1
    label.Size = UDim2.fromScale(1,1)
    label.Font = Enum.Font.Gotham
    label.TextScaled = true
    label.TextColor3 = Color3.new(1,1,1)
    label.TextStrokeTransparency = 0.6
    label.Parent = gui

    chestESPGui[chest] = { Highlight = hl, Gui = gui, Label = label }
end

local function removeESPForChest(chest)
    local entry = chestESPGui[chest]
    if entry then
        pcall(function() if entry.Highlight then entry.Highlight:Destroy() end end)
        pcall(function() if entry.Gui then entry.Gui:Destroy() end end)
        chestESPGui[chest] = nil
    end
end

-- Track collected chest instances
local collectedChests = {} -- keys: chest Instance -> true

-- Utility: get category keywords by display name
local function getKeywordsForCategory(displayName)
    for _, cat in ipairs(categories) do
        if cat.display == displayName then
            return cat.keywords
        end
    end
    return {}
end

-- Find all chest instances matching a set of keywords
local function getAllMatchingChestsByKeywords(keywords)
    local results = {}
    if not workspace:FindFirstChild("Items") then return results end
    for _, inst in ipairs(workspace.Items:GetChildren()) do
        if inst and inst:IsA("Model") and inst.PrimaryPart then
            local lower = string.lower(inst.Name)
            for _, kw in ipairs(keywords) do
                if string.find(lower, kw) and isChestModel(inst) then
                    table.insert(results, inst)
                    break
                end
            end
        end
    end
    return results
end

-- Helper: get nearby items spawned by a chest (from workspace.Items)
local function getNearbyChestItems(chest, radius)
    radius = radius or collectRadius
    local res = {}
    if not chest or not chest.PrimaryPart then return res end
    if not workspace:FindFirstChild("Items") then return res end
    local cp = chest.PrimaryPart.Position
    for _, item in ipairs(workspace.Items:GetChildren()) do
        if item and item:IsA("Model") and item.PrimaryPart and item ~= chest then
            if not string.find(string.lower(item.Name), "chest") then
                local d = (item.PrimaryPart.Position - cp).Magnitude
                if d <= radius then
                    table.insert(res, item)
                end
            end
        end
    end
    return res
end

-- Drag single item to camp (safe)
local function dragSingleItemToCamp(item)
    if not item or not item.PrimaryPart then return false end
    if not safeFire("RequestStartDraggingItem", item) then return false end
    task.wait(dragDelay)
    local ok = pcall(function() item:SetPrimaryPartCFrame(CFrame.new(campfirePos + Vector3.new(0,3,0))) end)
    task.wait(dragDelay)
    safeFire("StopDraggingItem", item)
    return ok
end

-- Collect one chest instance: TP -> Open -> Drag its nearby items -> mark collected -> return
local lastPlayerPos = nil

local function collectChestInstance(chest)
    if not chest or not chest.PrimaryPart then return 0 end

    -- Save original position before teleporting
    lastPlayerPos = HumanoidRootPart.CFrame

    lockPlayer(true)

    -- TP above chest
    HumanoidRootPart.CFrame = chest.PrimaryPart.CFrame + Vector3.new(0,4,0)
    task.wait(0.25)

    safeFire("RequestOpenItemChest", chest)
    task.wait(0.45)

    local items = getNearbyChestItems(chest)
    local count = 0

    -- Drag items ‚Üí bring to original location instead of campfire
    for _, it in ipairs(items) do
        if it and it.PrimaryPart then
            safeFire("RequestStartDraggingItem", it)
            task.wait(dragDelay)

            -- Move item to where YOU originally were
            pcall(function()
                it:SetPrimaryPartCFrame(lastPlayerPos + Vector3.new(0,3,0))
            end)

            task.wait(dragDelay)
            safeFire("StopDraggingItem", it)
            count = count + 1
        end
    end

    collectedChests[chest] = true

    -- Update ESP label
    local ent = chestESPGui[chest]
    if ent and ent.Label then
        local dist = math.floor((chest.PrimaryPart.Position - HumanoidRootPart.Position).Magnitude)
        ent.Label.Text = chest.Name .. " | " .. tostring(dist) .. "m | Collected"
    end

    -- Return YOU back to original position instead of campfire
    if lastPlayerPos then
        HumanoidRootPart.CFrame = lastPlayerPos + Vector3.new(0,4,0)
    end

    task.wait(0.12)
    lockPlayer(false)

    return count
end

-- Collect all chests matching a category (one-shot)
local Button = Section:Button({
    Title = "Collect Selected",
    Desc = "auto collect button",
    Callback = function()
        local keywords = getKeywordsForCategory(selectedCategory)
        if #keywords == 0 then notify("Failed", "No keywords for category"); return end

        local chests = getAllMatchingChestsByKeywords(keywords)
        if #chests == 0 then notify("Failed", "No chests found for "..selectedCategory); return end

        local total = 0
        for _, chest in ipairs(chests) do
            if not collectedChests[chest] then
                local c = collectChestInstance(chest)
                total = total + c
                notify("Chest Collected", ("%s ‚Üí %d item(s)"):format(chest.Name, c))
                task.wait(0.12)
            end
        end

        if total > 0 then
            notify("Success", ("Collected %d item(s) from category '%s'"):format(total, selectedCategory))
        else
            notify("Notice", "No new items collected")
        end
    end
})

-- Auto-collect selected category (continuous)
local autoCollectCategory = false
local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Auto Collect chest",
    Desc = "Auto collect chest",
    Value = false,
    Callback = function(state)
        autoCollectCategory = state
        if autoCollectCategory then
            spawn(function()
                while autoCollectCategory do
                    local keywords = getKeywordsForCategory(selectedCategory)
                    if #keywords == 0 then notify("Failed", "No chest found"); autoCollectCategory = false; break end

                    local chests = getAllMatchingChestsByKeywords(keywords)
                    local foundNew = false

                    for _, chest in ipairs(chests) do
                        if not autoCollectCategory then break end
                        if not collectedChests[chest] then
                            foundNew = true
                            local c = collectChestInstance(chest)
                            notify("Chest Collected", ("%s ‚Üí %d item(s)"):format(chest.Name, c))
                            task.wait(0.12)
                        end
                    end

                    if not foundNew then
                        notify("Finished", "No more new chests found explore the map")
                        autoCollectCategory = false
                        break
                    end

                    task.wait(0.25)
                end
            end)
        end
    end
})

-- ESP toggle + update loop (shows all chests matching any category)
local chestESPEnabled = false
local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Chest ESP",
    Desc = "Show chest highlight",
    Value = false,
    Callback = function(s) 
        chestESPEnabled = s
        if not s then
            -- cleanup GUIs
            for inst, _ in pairs(chestESPGui) do removeESPForChest(inst) end
        end
    end
})

RunService.RenderStepped:Connect(function()
    if not chestESPEnabled then return end
    if not workspace:FindFirstChild("Items") then return end

    -- gather all chests matching any category's keywords
    local active = {}
    for _, cat in ipairs(categories) do
        local chests = getAllMatchingChestsByKeywords(cat.keywords)
        for _, chest in ipairs(chests) do
            active[chest] = true
            createESPForChest(chest)
            local ent = chestESPGui[chest]
            if ent and ent.Label and HumanoidRootPart and chest.PrimaryPart then
                local dist = math.floor((chest.PrimaryPart.Position - HumanoidRootPart.Position).Magnitude)
                local text = chest.Name .. " | " .. tostring(dist) .. "m"
                if collectedChests[chest] then text = text .. " | Collected" end
                ent.Label.Text = text
            end
        end
    end

    -- remove ESPs that are no longer active
    for inst, _ in pairs(chestESPGui) do
        if not active[inst] then removeESPForChest(inst) end
    end
end)

local Section = AutoTab:Section({ 
    Title = "auto fuel",
    Icon = "flame", 
})

-- ====== Auto Tab / AutoFuel ======
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents")
local Workspace = game:GetService("Workspace")

local AutoFuel = {
    Enabled = false,
    Threshold = 70,
    SelectedFuel = { "All" },
    MaxPerCycle = 12,
    ESPEnabled = false,
    _lastFail = 0,
    _lastNotify = 0,
}

local FuelList = { "Corpse", "Alien", "Log", "Chair", "Coal", "Fuel Canister", "Biofuel" }

-- Drag safety
_G.RyZen_DragLock = _G.RyZen_DragLock or false
local function safeStartDrag(item)
    if not item or not item.Parent or not item.PrimaryPart then return false end
    if item.GetAttribute and item:GetAttribute("RyZen_BeingDragged") then return false end
    if _G.RyZen_DragLock then return false end
    _G.RyZen_DragLock = true
    local ok = false
    pcall(function()
        if RS and RS:FindFirstChild("RequestStartDraggingItem") then
            RS.RequestStartDraggingItem:FireServer(item)
            ok = true
            if item.SetAttribute then pcall(function() item:SetAttribute("RyZen_BeingDragged", "AutoFuel") end) end
        end
    end)
    if not ok then _G.RyZen_DragLock = false end
    return ok
end
local function safeStopDrag(item)
    pcall(function() if RS and RS:FindFirstChild("StopDraggingItem") then RS.StopDraggingItem:FireServer(item) end end)
    if item and item.SetAttribute then pcall(function() item:SetAttribute("RyZen_BeingDragged", nil) end) end
    _G.RyZen_DragLock = false
end

-- UI widgets
Section:Dropdown({
    Flag = "AutoTab",
    Title = "Fuel Types",
    Desc = "Pick which fuels to bring ( don't select any to bring all!)",
    Values = FuelList,
    Value = { "All" },
    Multi = true,
    AllowNone = false,
    Callback = function(selected)
        if type(selected) ~= "table" then AutoFuel.SelectedFuel = { tostring(selected) } else AutoFuel.SelectedFuel = selected end
        print("[AutoFuel] SelectedFuel ->", table.concat(AutoFuel.SelectedFuel, ", "))
    end
})

Section:Toggle({ Flag = "AutoTab", Title = "Auto Fuel", Desc = "Auto bring fuel when below slider!", Default = false, Callback = function(state) AutoFuel.Enabled = state print("[AutoFuel] Enabled ->", state) end })
Section:Slider({ Flag = "AutoTab", Title = "Bring When Fuel", Desc = "Bring when campfire fuel is below this slider", Step = 1, Value = { Min = 0, Max = 200, Default = AutoFuel.Threshold }, Callback = function(value) AutoFuel.Threshold = math.floor(value) print("[AutoFuel] Threshold ->", AutoFuel.Threshold) end })
Section:Toggle({ Flag = "AutoTab", Title = "Fuel ESP", Desc = "Show campfire fuel health", Default = false, Callback = function(state) AutoFuel.ESPEnabled = state if not state then pcall(function() destroyFuelESP() end) end end })

local function nameMatches(itemName, fuelName)
    if not itemName or not fuelName then return false end
    return string.find(string.lower(itemName), string.lower(fuelName), 1, true) ~= nil
end

local function buildFuelsToBring()
    if AutoFuel.SelectedFuel and table.find(AutoFuel.SelectedFuel, "All") then
        local copy = {}
        for _, v in ipairs(FuelList) do table.insert(copy, v) end
        return copy
    else
        local out = {}
        if AutoFuel.SelectedFuel then for _, v in ipairs(AutoFuel.SelectedFuel) do table.insert(out, v) end end
        return out
    end
end

-- ESP
local fuelESPGui = nil
local fuelESPConn = nil
function ensureFuelESP(campfire)
    if fuelESPGui and (not fuelESPGui.Parent or not fuelESPGui.Adornee) then pcall(function() fuelESPGui:Destroy() end) fuelESPGui = nil end
    if fuelESPConn and (fuelESPGui == nil) then pcall(function() fuelESPConn:Disconnect() end) fuelESPConn = nil end
    if not AutoFuel.ESPEnabled then return end
    if not campfire or not campfire.PrimaryPart then return end
    if fuelESPGui and fuelESPGui.Adornee == campfire.PrimaryPart then return end

    if fuelESPGui then pcall(function() fuelESPGui:Destroy() end) end
    local gui = Instance.new("BillboardGui")
    gui.Name = "FuelESP"
    gui.Size = UDim2.new(0, 160, 0, 40)
    gui.Adornee = campfire.PrimaryPart
    gui.AlwaysOnTop = true
    gui.StudsOffset = Vector3.new(0, 3, 0)

    local txt = Instance.new("TextLabel")
    txt.Size = UDim2.new(1, 0, 1, 0)
    txt.BackgroundTransparency = 1
    txt.TextColor3 = Color3.fromRGB(255,255,255)
    txt.TextStrokeTransparency = 0
    txt.TextScaled = true
    txt.Font = Enum.Font.Gotham
    txt.Parent = gui

    gui.Parent = campfire
    fuelESPGui = gui

    if fuelESPConn then pcall(function() fuelESPConn:Disconnect() end) end
    fuelESPConn = RunService.Heartbeat:Connect(function()
        if not fuelESPGui or not fuelESPGui.Parent or not campfire or not campfire.Parent or not campfire.PrimaryPart then
            pcall(function() if fuelESPGui then fuelESPGui:Destroy() end end)
            fuelESPGui = nil
            if fuelESPConn then fuelESPConn:Disconnect(); fuelESPConn = nil end
            return
        end
        fuelESPGui.Enabled = AutoFuel.ESPEnabled
        local fuelRem = campfire:GetAttribute("FuelRemaining") or 0
        local fuelTarget = campfire:GetAttribute("FuelTarget") or 0
        txt.Text = ("üî• %d / %d | Threshold: %d"):format(fuelRem, fuelTarget, AutoFuel.Threshold or 0)
    end)
end

function destroyFuelESP()
    if fuelESPConn then pcall(function() fuelESPConn:Disconnect() end) end
    fuelESPConn = nil
    if fuelESPGui then pcall(function() fuelESPGui:Destroy() end) end
    fuelESPGui = nil
end

-- ====== MAIN LOOP (NO GOTO / NO CONTINUE) ======
task.spawn(function()
    while true do
        task.wait(0.7)

        -- preliminary variables
        local shouldProcess = true
        local map = Workspace:FindFirstChild("Map")
        local cg  = map and map:FindFirstChild("Campground")
        local fire = cg and cg:FindFirstChild("MainFire")

        -- 1) If no campfire or PrimaryPart: cleanup ESP and skip processing this cycle
        if not fire or not fire.PrimaryPart then
            pcall(function() destroyFuelESP() end)
            shouldProcess = false
        end

        -- 2) ESP update if enabled (only if fire exists)
        if shouldProcess and AutoFuel.ESPEnabled and fire then
            pcall(function() ensureFuelESP(fire) end)
        end

        -- 3) If AutoFuel not enabled, skip
        if shouldProcess and not AutoFuel.Enabled then
            shouldProcess = false
        end

        -- 4) Check fuelRemaining and skip if already above threshold
        local fuelRemaining = 0
        if shouldProcess and fire then
            fuelRemaining = fire:GetAttribute("FuelRemaining") or 0
            if fuelRemaining >= AutoFuel.Threshold then
                shouldProcess = false
            end
        end

        -- 5) Items folder must exist
        local itemsFolder = nil
        if shouldProcess then
            itemsFolder = Workspace:FindFirstChild("Items")
            if not itemsFolder then
                if WindUI and (time() - AutoFuel._lastFail) > 6 then
                    AutoFuel._lastFail = time()
                    pcall(function() WindUI:Notify({ Title = "Auto Fuel", Icon = "rbxassetid://84501312005643", Content = "No items folder found in workspace.", Duration = 3 }) end)
                end
                shouldProcess = false
            end
        end

        -- 6) Build fuels and validate selection
        local fuels = nil
        if shouldProcess then
            fuels = buildFuelsToBring()
            local validSelection = (fuels and type(fuels) == "table" and #fuels > 0)
            if not validSelection then
                if WindUI and (time() - AutoFuel._lastFail) > 2 then
                    AutoFuel._lastFail = time()
                    pcall(function() WindUI:Notify({ Title = "Auto Fuel", Icon = "rbxassetid://84501312005643", Content = "No fuel selected ‚Äî choose a fuel type!", Duration = 3 }) end)
                end
                shouldProcess = false
            end
        end

        -- If only "All" selected, ensure fuels list is full
        if shouldProcess and #AutoFuel.SelectedFuel == 1 and AutoFuel.SelectedFuel[1] == "All" then
            fuels = buildFuelsToBring()
        end

        -- 7) If shouldProcess is false, skip bringing items this cycle
        if not shouldProcess then
            -- next iteration
        else
            -- proceed with bringing items
            local foundAny = false
            local successCount = 0
            local targetPos = Vector3.new(4.95910645e-05, 9.5, -7.62939453e-06)

            for _, fuelName in ipairs(fuels) do
                local perTypeCount = 0
                -- iterate children safely (snapshot)
                local children = itemsFolder:GetChildren()
                for _, item in ipairs(children) do
                    if perTypeCount >= AutoFuel.MaxPerCycle then break end
                    if not item or not item:IsA("Model") or not item.PrimaryPart then
                        -- skip this child
                    else
                        if nameMatches(item.Name, fuelName) then
                            foundAny = true
                            fuelRemaining = fire:GetAttribute("FuelRemaining") or fuelRemaining
                            if fuelRemaining >= AutoFuel.Threshold then
                                break
                            end

                            if safeStartDrag(item) then
                                task.wait(0.05)
                                pcall(function() if item.PrimaryPart then item:SetPrimaryPartCFrame(CFrame.new(targetPos)) end end)
                                task.wait(0.06)
                                safeStopDrag(item)

                                perTypeCount = perTypeCount + 1
                                successCount = successCount + 1
                                task.wait(0.06)
                            end
                        end
                    end
                end

                fuelRemaining = fire:GetAttribute("FuelRemaining") or fuelRemaining
                if fuelRemaining >= AutoFuel.Threshold then break end
            end

            -- Notifications (no spam)
            if WindUI then
                if successCount > 0 then
                    local newFuel = fire:GetAttribute("FuelRemaining") or fuelRemaining
                    pcall(function() WindUI:Notify({ Title = "Auto Fuel", Icon = "rbxassetid://84501312005643", Content = ("Success collected (%d items). Fuel is now (%d)."):format(successCount, newFuel), Duration = 3 }) end)
                elseif not foundAny and (time() - AutoFuel._lastFail) > 2 then
                    AutoFuel._lastFail = time()
                    pcall(function() WindUI:Notify({ Title = "Auto Fuel", Icon = "rbxassetid://84501312005643", Content = "Failed. No items found explore the map!", Duration = 3 }) end)
                end
            end
        end
        -- loop repeats automatically
    end
end)

local Section = AutoTab:Section({ 
    Title = "Auto Cut Trees",
    Icon = "axe", 
})

-- AutoCut Trees ‚Äî No varargs / corrected
-- Uses ToolDamageObject patterns and watches workspace.Items for drops

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

local plr = Players.LocalPlayer

-- SETTINGS
local SETTINGS = {
    AutoCut = false,
    Targets = {"All"},
    Range = 80,
    ShowHP = false,
    HitDelay = 0.01,
    ConfirmDropTimeout = 2.0,
    TryDamageValues = { "1" },
    TrySignatures = {
        "tool_damage_numeric_cframe",   -- remote(target, realTool, numberDamage, charCFrame)
        "tool_damage_string_cframe",    -- remote(target, realTool, tostring(damage), charCFrame)
        "tool_damage_count_cframe"      -- remote(target, realTool, "1", tostring(counter), charCFrame)
    }
}

-- find ToolDamageObject remote under ReplicatedStorage
local function findToolRemote()
    local name = "ToolDamageObject"
    local direct = ReplicatedStorage:FindFirstChild(name)
    if direct and (direct.ClassName == "RemoteFunction" or direct.ClassName == "RemoteEvent") then
        return direct
    end
    for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
        if v.Name == name and (v.ClassName == "RemoteFunction" or v.ClassName == "RemoteEvent") then
            return v
        end
    end
    return nil
end

local TOOL_REMOTE = findToolRemote()
if TOOL_REMOTE then
    print("[AutoCut] Found remote:", TOOL_REMOTE:GetFullName(), "class:", TOOL_REMOTE.ClassName)
else
    warn("[AutoCut] ToolDamageObject remote NOT found under ReplicatedStorage ‚Äî script may fail.")
end

-- map helpers
local function getMapFolders()
    local root = Workspace:FindFirstChild("Map") or Workspace:FindFirstChild("map")
    if not root then return nil, nil end
    local fol = root:FindFirstChild("Foliage") or root:FindFirstChild("foliage")
    local lm = root:FindFirstChild("Landmarks") or root:FindFirstChild("landmarks")
    return fol, lm
end

local function isTreeModel(m)
    if not m or not m:IsA("Model") then return false end
    if type(m.GetAttribute) ~= "function" then return false end
    local hp = m:GetAttribute("Health")
    return hp ~= nil
end

local function getTreesInRange(range)
    range = tonumber(range) or SETTINGS.Range
    local out = {}
    local fol, lm = getMapFolders()
    local char = plr.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return out end
    local hrp = char.HumanoidRootPart
    local function checkFolder(f)
        if not f then return end
        for _, child in ipairs(f:GetChildren()) do
            if isTreeModel(child) then
                local part = child.PrimaryPart or child:FindFirstChildWhichIsA("BasePart")
                if part then
                    local dist = (part.Position - hrp.Position).Magnitude
                    if dist <= range then
                        table.insert(out, child)
                    end
                end
            end
        end
    end
    checkFolder(fol)
    checkFolder(lm)
    return out
end

-- tool model candidate detection
local function scanContainerForCandidates(container, source, list)
    if not container then return end
    for _, v in ipairs(container:GetChildren()) do
        if v and v.Name then
            local special = false
            if type(v.GetAttribute) == "function" then
                if v:GetAttribute("WeaponDamage") ~= nil or v:GetAttribute("ToolCooldown") ~= nil then
                    special = true
                end
            end
            table.insert(list, { inst = v, source = source, special = special })
        end
    end
end

local function findToolModelCandidates()
    local candidates = {}
    scanContainerForCandidates(plr:FindFirstChild("Inventory"), "Inventory", candidates)
    scanContainerForCandidates(plr.Character, "Character", candidates)
    scanContainerForCandidates(plr:FindFirstChild("Backpack"), "Backpack", candidates)
    -- sort special ones first
    table.sort(candidates, function(a,b)
        return (a.special and 1 or 0) > (b.special and 1 or 0)
    end)
    local seen = {}
    local out = {}
    for _, c in ipairs(candidates) do
        if c.inst and not seen[c.inst] then
            seen[c.inst] = true
            table.insert(out, c)
        end
    end
    return out
end

local PREFERRED = { "Chainsaw", "Strong Axe", "Good Axe", "Old Axe" }
local function pickBestCandidate(cands)
    for _, pref in ipairs(PREFERRED) do
        for _, c in ipairs(cands) do
            if c.inst and c.inst.Name and string.find(string.lower(c.inst.Name), string.lower(pref)) then
                return c.inst, c.source
            end
        end
    end
    if #cands > 0 then return cands[1].inst, cands[1].source end
    return nil, nil
end

-- confirmation helpers
local function waitForDropNear(pos, timeout, radius)
    radius = radius or 10
    timeout = timeout or SETTINGS.ConfirmDropTimeout
    local itemsRoot = Workspace:FindFirstChild("Items") or Workspace:FindFirstChild("items")
    if not itemsRoot then return false, "no items folder" end
    local before = {}
    for _, c in ipairs(itemsRoot:GetChildren()) do before[c] = true end
    local elapsed = 0
    while elapsed < timeout do
        for _, c in ipairs(itemsRoot:GetChildren()) do
            if not before[c] then
                if pos and (c:IsA("Model") or c:IsA("BasePart")) then
                    local part = c:FindFirstChildWhichIsA("BasePart") or (c:IsA("BasePart") and c)
                    if part and (part.Position - pos).Magnitude <= radius then
                        return true, c
                    end
                else
                    return true, c
                end
            end
        end
        task.wait(0.02)
        elapsed = elapsed + 0.12
    end
    return false, "no new drop"
end

local function healthDecreased(old, model)
    if old == nil then return nil end
    local now = model:GetAttribute("Health")
    if now == nil then return nil end
    return tonumber(now) < tonumber(old)
end

-- safeInvoke uses an argument table (no varargs)
local function safeInvoke(remote, argsTable)
    if not remote then return false, "no remote" end
    if type(argsTable) ~= "table" then return false, "args must be table" end
    if remote.ClassName == "RemoteFunction" then
        local ok, res = pcall(function()
            return remote:InvokeServer(unpack(argsTable))
        end)
        if ok then return true, res else return false, res end
    else
        local ok, res = pcall(function()
            remote:FireServer(unpack(argsTable))
            return true
        end)
        if ok then return true, res else return false, res end
    end
end

-- try different signatures for a hit without varargs
local hitCounter = 1
local function tryHitWithCandidate(remote, candidateInst, tree)
    if not remote or not candidateInst or not tree then return false, "missing param" end
    local part = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
    if not part then return false, "no basepart" end

    -- build damage candidates from attributes then fallback list
    local dmgVals = {}
    if type(candidateInst.GetAttribute) == "function" then
        local wd = candidateInst:GetAttribute("WeaponDamage")
        if wd ~= nil then table.insert(dmgVals, wd) end
        local rd = candidateInst:GetAttribute("WeaponResourceDamage")
        if rd ~= nil then table.insert(dmgVals, rd) end
    end
    for _, v in ipairs(SETTINGS.TryDamageValues) do table.insert(dmgVals, v) end

    local uniq = {}
    local dmgList = {}
    for _, v in ipairs(dmgVals) do
        local s = tostring(v)
        if not uniq[s] then uniq[s] = true; table.insert(dmgList, v) end
    end
    if #dmgList == 0 then dmgList = { "1" } end

    for _, sig in ipairs(SETTINGS.TrySignatures) do
        for _, dmgV in ipairs(dmgList) do
            local success, info = false, nil
            local args = nil
            if sig == "tool_damage_numeric_cframe" then
                args = { tree, candidateInst, dmgV, (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            elseif sig == "tool_damage_string_cframe" then
                args = { tree, candidateInst, tostring(dmgV), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            elseif sig == "tool_damage_count_cframe" then
                args = { tree, candidateInst, "1", tostring(hitCounter), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            else
                args = { tree, candidateInst, tostring(dmgV), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            end

            local ok, res = safeInvoke(remote, args)
            task.wait(0.12) -- small pause to let server update
            local beforeHealth = nil -- we captured before above? do check now
            -- Note: We intentionally check health after the hit:
            local decreased = healthDecreased(tree:GetAttribute("Health"), tree)
            if decreased == true then
                hitCounter = hitCounter + 1
                return true, ("health decreased with sig "..sig.." dmg="..tostring(dmgV))
            end

            -- also check for drops near the tree
            local pos = (part and part.Position) and part.Position or nil
            local found, dropInfo = waitForDropNear(pos, 0.25, 12)
            if found then
                hitCounter = hitCounter + 1
                return true, ("drop detected with sig "..sig.." dmg="..tostring(dmgV).." drop="..tostring(dropInfo.Name))
            end

            if ok then
                hitCounter = hitCounter + 1
                return true, ("remote call returned ok for sig "..sig.." dmg="..tostring(dmgV))
            end

            task.wait(0.2)
        end
    end

    return false, "exhausted signatures"
end

-- TREE HP ESP (optimized, toggle-safe)

espFolder = Workspace:FindFirstChild("TreeHPESP") or Instance.new("Folder", Workspace)
espFolder.Name = "TreeHPESP"

espMap = espMap or {}     -- ensure table exists
SETTINGS = SETTINGS or {} -- ensure settings exists
SETTINGS.ShowHP = SETTINGS.ShowHP or false

espMap = {}
SETTINGS = SETTINGS or {}
SETTINGS.ShowHP = SETTINGS.ShowHP or false

espFolder = Workspace:FindFirstChild("TreeHPESP") or Instance.new("Folder", Workspace)
espFolder.Name = "TreeHPESP"
espMap = espMap or {}

-- Remove ESP for a single tree
function removeESP(tree)
    local info = espMap[tree]
    if info then
        pcall(function() if info.bb and info.bb.Parent then info.bb:Destroy() end end)
        espMap[tree] = nil
    end
end

-- Remove all ESP
function removeAllESP()
    for tree,_ in pairs(espMap) do removeESP(tree) end
end

-- Update or create ESP for a tree
function updateESP(tree)
    if not SETTINGS.ShowHP then return removeESP(tree) end
    if not tree or not tree.Parent then return removeESP(tree) end

    local root = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
    if not root then return removeESP(tree) end

    local info = espMap[tree]
    if not info then
        local bb = Instance.new("BillboardGui")
        bb.Name = "AutoCut_HP"
        bb.Adornee = root
        bb.Size = UDim2.new(0,120,0,22)
        bb.StudsOffset = Vector3.new(0,2.2,0)
        bb.AlwaysOnTop = true
        bb.Parent = espFolder

        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.fromScale(1,1)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.GothamBold
        lbl.TextScaled = true
        lbl.TextColor3 = Color3.new(1,1,1)
        lbl.Parent = bb

        espMap[tree] = { bb = bb, lbl = lbl }
        info = espMap[tree]
    end

    local hp = tree:GetAttribute("Health")
    info.lbl.Text = (tree.Name or "Tree").." | HP: "..(hp and math.floor(tonumber(hp) or hp) or "N/A")
    info.bb.Enabled = SETTINGS.ShowHP
end

-- Continuously update all trees
game:GetService("RunService").RenderStepped:Connect(function()
    if not SETTINGS.ShowHP then return end
    local fol, lm = Workspace:FindFirstChild("Map") or Workspace:FindFirstChild("map")
    if fol then fol = fol:FindFirstChild("Foliage") or fol:FindFirstChild("foliage") end
    if lm then lm = lm:FindFirstChild("Landmarks") or lm:FindFirstChild("landmarks") end

    local trees = {}
    if fol then for _,t in ipairs(fol:GetChildren()) do if t:GetAttribute("Health") then table.insert(trees,t) end end end
    if lm then for _,t in ipairs(lm:GetChildren()) do if t:GetAttribute("Health") then table.insert(trees,t) end end end

    for _,t in ipairs(trees) do updateESP(t) end
end)

-- Clean up on tree removal
Workspace.DescendantRemoving:Connect(function(desc)
    if espMap[desc] then removeESP(desc) end
end)

-- MAIN LOOP ‚Äî concurrent tree hits
task.spawn(function()
    while true do
        task.wait(1) -- minimal wait to prevent freezing
        if not SETTINGS.AutoCut then
            task.wait(1)
        else
            local trees = getTreesInRange(SETTINGS.Range)
            if #trees == 0 then
                task.wait(1)
            else
                local candidates = findToolModelCandidates()
                local candidateInst, candidateSrc = pickBestCandidate(candidates)
                if not candidateInst then
                    print("[AutoCut] No tool candidate found. Candidates:", #candidates)
                    task.wait(1)
                else
                    for _, tree in ipairs(trees) do
                        -- spawn each tree hit in its own thread
                        task.spawn(function()
                            if tree and tree.Parent then
                                -- filter by selected types
                                local selected = SETTINGS.Targets or {"All"}
                                local treatAll = false
                                for _, v in ipairs(selected) do
                                    if v == "All" then treatAll = true; break end
                                end
                                local shouldProcess = treatAll
                                if not treatAll then
                                    local lname = (tree.Name or ""):lower()
                                    for _, v in ipairs(selected) do
                                        if lname:find(v:lower()) then
                                            shouldProcess = true
                                            break
                                        end
                                    end
                                end

                                if shouldProcess then
                                    if SETTINGS.ShowHP then updateESP(tree) end
                                    -- try hitting tree with candidate tool
                                    local ok, info = tryHitWithCandidate(TOOL_REMOTE, candidateInst, tree)
                                    print("[AutoCut] Hit result:", tostring(ok), tostring(info))
                                end
                            end
                        end)
                    end
                end
            end
        end
    end
end)

local Dropdown = Section:Dropdown({
    Flag = "AutoTab",
        Title="Tree Types",
        Desc="Choose tree types (choosing all might slow down cutting and lags you)",
        Values={"All","Small Tree","Snowy Small Tree","TreeBig1","TreeBig2"," TreeBig3"},
        Value="All",
        Multi=true,
        AllowNone=true,
        Callback=function(sel)
            if type(sel)=="table" and #sel>0 then SETTINGS.Targets = sel else SETTINGS.Targets = {"All"} end
            print("Targets ->", HttpService:JSONEncode(SETTINGS.Targets))
        end
    })

local Input = Section:Input({
    Title = "Range",
    Desc = "Max distance",
    Value = tostring(SETTINGS.Range),
    Callback = function(v)
        local n = tonumber(v)
        if n then
            SETTINGS.Range = math.clamp(n, 1, 2000)
            print("Range ->", SETTINGS.Range)
        end
    end
})

local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Auto Cut",
    Desc = "Enable AutoCut",
    Value = SETTINGS.AutoCut,
    Callback = function(v)
        SETTINGS.AutoCut = not not v
    end
})

local Toggle = Section:Toggle({
    Flag = "AutoTab",
    Title = "Show Tree HP",
    Desc = "Toggle Tree HP ESP",
    Value = SETTINGS.ShowHP,
    Callback = function(v)
        SETTINGS.ShowHP = not not v
        if not SETTINGS.ShowHP then
            removeAllESP()
        end
    end
})

Section = AutoTab:Section({ 
    Title = "collect coins and flowers",
    Icon = "flower", 
})

--==============================--
--         Auto Tab
--==============================--

-- Services
Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
Workspace = game:GetService("Workspace")
StarterGui = game:GetService("StarterGui")

LocalPlayer = Players.LocalPlayer

-- Remotes
remotesFolder = ReplicatedStorage:FindFirstChild("RemoteEvents") or ReplicatedStorage
coinRemote = remotesFolder:FindFirstChild("RequestCollectCoints") or remotesFolder:FindFirstChild("RequestCollectCoins")
flowerRemote = remotesFolder:FindFirstChild("RequestPickFlower") or remotesFolder:FindFirstChild("RequestPickFlowers")

-- State
State = {
    RunningCoins = false,
    RunningFlowers = false,
    PerItemDelay = 0.05,
    BetweenItems = 0.03,
}

-- Helpers
function safeNotify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = 2})
    end)
    print("[Notify]", title, "-", text)
end

function safeGetPosition(item)
    if not item then return nil end
    if item:IsA("BasePart") then return item.Position end
    if item.PrimaryPart then return item.PrimaryPart.Position end
    local part = item:FindFirstChildWhichIsA("BasePart", true)
    if part then return part.Position end
    return nil
end

function callRemoteWithCandidates(remote, item)
    if not remote or not item then return false end
    local candidates = {item}
    if item.Parent then table.insert(candidates, item.Parent) end
    if item.PrimaryPart then table.insert(candidates, item.PrimaryPart) end
    for _,c in ipairs(candidates) do
        local ok,_ = pcall(function()
            if remote.InvokeServer then remote:InvokeServer(c)
            elseif remote.FireServer then remote:FireServer(c)
            end
        end)
        if ok then return true end
    end
    return false
end

function safeTPToPos(pos)
    if not pos then return end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if hrp then pcall(function() hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0)) end) end
end

-- Find coins and flowers
function findCoins()
    local out = {}
    local root = Workspace:FindFirstChild("Items") or Workspace
    for _,v in ipairs(root:GetDescendants()) do
        if (v:IsA("Model") or v:IsA("BasePart")) and v.Name:lower():find("coin") then
            table.insert(out, v)
        end
    end
    return out
end

function findFlowers()
    local out = {}
    for _,v in ipairs(Workspace:GetDescendants()) do
        if (v:IsA("Model") or v:IsA("BasePart")) and v.Name:lower():find("flower") then
            table.insert(out, v)
        end
    end
    return out
end

-- Infinite collector
function collectLoop(label, finderFunc, remote, runningFlag)
    task.spawn(function()
        while State[runningFlag] do
            local items = finderFunc()
            for _,item in ipairs(items) do
                if not State[runningFlag] then break end
                local pos = safeGetPosition(item)
                if pos then safeTPToPos(pos) end
                callRemoteWithCandidates(remote, item)
                task.wait(State.PerItemDelay)
            end
            task.wait(State.BetweenItems)
        end
        safeNotify("Auto Collect", label .. " stopped.")
    end)
end

-- Collect functions
function startCollectCoins()
    if State.RunningCoins then return end
    State.RunningCoins = true
    collectLoop("Coins", findCoins, coinRemote, "RunningCoins")
end

function stopCollectCoins()
    State.RunningCoins = false
end

function startCollectFlowers()
    if State.RunningFlowers then return end
    State.RunningFlowers = true
    collectLoop("Flowers", findFlowers, flowerRemote, "RunningFlowers")
end

function stopCollectFlowers()
    State.RunningFlowers = false
end

-- Toggles
Toggle = Section:Toggle({
    Title="Auto Collect Coins",
    Desc="Collect coins continuously",
    Default=false,
    Callback=function(v)
        if v then startCollectCoins() else stopCollectCoins() end
    end
})

Toggle = Section:Toggle({
    Title="Auto Collect Flowers",
    Desc="Collect flowers continuously",
    Default=false,
    Callback=function(v)
        if v then startCollectFlowers() else stopCollectFlowers() end
    end
})

safeNotify(" Join our Discord!")

--==============================--
--       Teleport Tab
--==============================--
local TeleportTab = Window:Tab({
    Title = "Teleport",
    Icon = "map-pin", -- optional
})

TPStructSection = TeleportTab:Section({ Title = "Structures", Icon = "map-pin" })
structuresFolder = workspace.Map.Landmarks
npcFolder = workspace.Characters

structuresList = {
    "Stronghold", "AlienMothership", "Frog Cave", "Military Base",
    "Ice Temple", "Bell Tower", "Research Facility", "Anvil",
    "Snow Clothing Shop", "Fishing Hut", "Volcano", "Cultist Generator Base",
    "Kings Palace"
}

npcList = {"Fairy", "Caravan", "Bird Watcher", "Pelt Trader"}
selectedStructure = structuresList[1]
selectedNPC = npcList[1]
notifySpawnToggle = false
notifiedStructures = {}
notifiedNPCs = {}

function teleportTo(pos)
    plr = game.Players.LocalPlayer
    if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    end
end

-- Structure dropdown + TP
TeleportTab:Dropdown({
    Title = "Structure",
    Desc = "Select a structure",
    Values = structuresList,
    Value = selectedStructure,
    Callback = function(option) selectedStructure = option end
})

TeleportTab:Button({
    Title = "TP to Structure",
    Desc = "Teleport to selected structure",
    Callback = function()
        struct = structuresFolder:FindFirstChild(selectedStructure)
        if struct and struct.PrimaryPart then
            teleportTo(struct.PrimaryPart.Position)
        else
            WindUI:Notify({Title = "TP Failed", Content = "Structure not spawned/too far away!", Duration=3})
        end
    end
})

TeleportTab:Divider()

-- NPC dropdown + TP
TeleportTab:Dropdown({
    Flag = "AutoTab",
    Title = "NPC",
    Desc = "Select an NPC",
    Values = npcList,
    Value = selectedNPC,
    Callback = function(option) selectedNPC = option end
})

TeleportTab:Button({
    Title = "TP to NPC",
    Desc = "Teleport to selected NPC",
    Callback = function()
        npc = npcFolder:FindFirstChild(selectedNPC)
        if npc and npc.PrimaryPart then
            teleportTo(npc.PrimaryPart.Position)
        else
            WindUI:Notify({Title = "TP Failed", Content = "NPC not spawned/too far!", Duration=3})
        end
    end
})

TeleportTab:Divider()

TeleportTab:Toggle({
    Flag = "AutoTab",
    Title = "Notify on Spawn",
    Desc = "Notify when structure or NPC spawns",
    Callback = function(state) notifySpawnToggle = state end
})

-- Spawn detection loop
task.spawn(function()
    while true do
        for _, structName in ipairs(structuresList) do
            struct = structuresFolder:FindFirstChild(structName)
            if struct and not notifiedStructures[structName] then
                notifiedStructures[structName] = true
                if notifySpawnToggle then
                    WindUI:Notify({Title="Structure Spawned", Content=structName.." has spawned!", Duration=3})
                end
            elseif not struct then
                notifiedStructures[structName] = nil
            end
        end
        for _, npcName in ipairs(npcList) do
            npc = npcFolder:FindFirstChild(npcName)
            if npc and not notifiedNPCs[npcName] then
                notifiedNPCs[npcName] = true
                if notifySpawnToggle then
                    WindUI:Notify({Title="NPC Spawned", Content=npcName.." has spawned!", Duration=3})
                end
            elseif not npc then
                notifiedNPCs[npcName] = nil
            end
        end
        task.wait(1)
    end
end)

VisualTab = Window:Tab({
    Title = "Visuals",
   Icon = "scan",
})

-- SERVICES
RunService = game:GetService("RunService")
Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
Lighting = game:GetService("Lighting")
LocalPlayer = Players.LocalPlayer

-- ESP SETTINGS
ESPSettings = {
    ShowName=false,
    ShowDistance=false,
    Highlight=false,
    ShowFuel=false,
    ShowGears=false,
    ShowFood=false,
    ShowWeapons=false,
    ShowOthers=false,
    SelectedFuel={},
    SelectedGears={},
    SelectedFood={},
    SelectedWeapons={},
    SelectedOthers={},
}

FuelList = {"Corpse","Sapling","Alien","Log","Chair","Coal","Fuel Canister","Oil Barrel","Biofuel"}
GearsList = {"Bolt","Tyre","Sheet Metal","Old Radio","Broken Fan","Broken Microwave","Washing Machine","Old Car Engine","UFO Scrap","UFO Component","UFO Junk","Cultist Gem","Gem of the Forest"}
FoodList = {"Carrot","Berry","Morsel","Steak","Ribs","Cooked Morsel","Cooked Steak","Cooked Ribs","Bandage","Medkit","Chili"}
WeaponList = {"Morning star","Laser Sword","Raygun","Chainsaw","Strong Axe","Spear","Good Axe","Revolver","Rifle","Tactical Shotgun","Revolver Ammo","Rifle Ammo","Alien Armour","Leather Body","Iron Body","Thorn Body","Riot Shield"}
OthersList = {"Sack","Seed Box","Chainsaw","Old Flashlight","Strong Flastlight","Bunny Foot","Wolf Pelt","Bear Pelt","Alpha Wolf Pet","Artic Fox Pelt","Polar Bear Pelt","Mammoth Tusk","Flowers","Coin Stack"}

ESPObjects = {} -- maps item -> {Gui, Label, Highlight, Root}

-- UTILITIES
function destroyESP(item)
    entry = ESPObjects[item]
    if not entry then return end
    if entry.Gui and entry.Gui.Parent then pcall(function() entry.Gui:Destroy() end) end
    if entry.Highlight and entry.Highlight.Parent then pcall(function() entry.Highlight:Destroy() end) end
    ESPObjects[item] = nil
end

function findRootPart(item)
    if not item then return nil end
    if item:IsA("BasePart") then return item end
    if item:IsA("Model") then
        if item.PrimaryPart and item.PrimaryPart:IsA("BasePart") then return item.PrimaryPart end
        bp = item:FindFirstChildWhichIsA("BasePart")
        if bp then return bp end
    end
    for _,v in pairs(item:GetDescendants()) do
        if v:IsA("BasePart") then return v end
    end
    return nil
end

function createESP(item)
    if ESPObjects[item] then return end
    root = findRootPart(item)
    if not root then return end

    gui = Instance.new("BillboardGui")
    gui.Name = "ItemESP"
    gui.Size = UDim2.new(0,80,0,16)
    gui.Adornee = root
    gui.AlwaysOnTop = true
    gui.StudsOffset = Vector3.new(0,1.5,0)

    txt = Instance.new("TextLabel")
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency=1
    txt.TextColor3=Color3.fromRGB(255,255,255)
    txt.TextStrokeTransparency=0
    txt.TextScaled=true
    txt.Font=Enum.Font.Gotham
    txt.Text=""
    txt.Parent=gui

    gui.Parent=Workspace

    hl = Instance.new("Highlight")
    hl.FillTransparency=0.5
    hl.OutlineTransparency=0
    hl.Adornee=root
    hl.Enabled=false
    hl.Parent=Workspace

    ESPObjects[item]={Gui=gui,Label=txt,Highlight=hl,Root=root}
end

function itemMatchesFilter(item,type)
    list = {}
    if type=="Fuel" then list=ESPSettings.SelectedFuel end
    if type=="Gears" then list=ESPSettings.SelectedGears end
    if type=="Food" then list=ESPSettings.SelectedFood end
    if type=="Weapons" then list=ESPSettings.SelectedWeapons end
    if type=="Others" then list=ESPSettings.SelectedOthers end
    if not list or #list==0 then return false end
    for _,v in pairs(list) do
        if v=="All" or item.Name==v then return true end
    end
    return false
end

-- MAIN LOOP
if MainConn then pcall(function() MainConn:Disconnect() end) MainConn=nil end

MainConn = RunService.Heartbeat:Connect(function()
    if not Workspace:FindFirstChild("Items") then
        for obj,_ in pairs(ESPObjects) do destroyESP(obj) end
        return
    end

    children = Workspace.Items:GetChildren()
    seen = {}

    for _,item in pairs(children) do
        if item and item.Parent then
            show=false
            if ESPSettings.ShowFuel and itemMatchesFilter(item,"Fuel") then show=true end
            if ESPSettings.ShowGears and itemMatchesFilter(item,"Gears") then show=true end
            if ESPSettings.ShowFood and itemMatchesFilter(item,"Food") then show=true end
            if ESPSettings.ShowWeapons and itemMatchesFilter(item,"Weapons") then show=true end
            if ESPSettings.ShowOthers and itemMatchesFilter(item,"Others") then show=true end

            if show then
                if not ESPObjects[item] then createESP(item) end
                entry = ESPObjects[item]
                if entry and (not entry.Root or not entry.Root.Parent) then
                    destroyESP(item)
                    createESP(item)
                    entry=ESPObjects[item]
                end
                if entry and entry.Gui and entry.Label then
                    entry.Gui.Enabled=true
                    nameText = ESPSettings.ShowName and item.Name or ""
                    distText = ""
                    if ESPSettings.ShowDistance then
                        char=LocalPlayer and LocalPlayer.Character
                        primary=char and char.PrimaryPart
                        if primary and entry.Root and entry.Root.Position then
                            dist=(primary.Position-entry.Root.Position).Magnitude
                            distText=(nameText~="" and " | " or "")..string.format("%.0f m",dist)
                        end
                    end
                    entry.Label.Text=nameText..distText
                    if entry.Highlight then entry.Highlight.Enabled=ESPSettings.Highlight end
                end
                seen[item]=true
            else
                if ESPObjects[item] then destroyESP(item) end
            end
        end
    end

    for obj,_ in pairs(ESPObjects) do
        if not seen[obj] then destroyESP(obj) end
    end
end)

Section = VisualTab:Section({ 
    Title = "Settings",
    Icon = "settings",
})

-- GUI TOGGLES
VisualTab:Toggle({
    Flag = "AutoTab",
    Title="ESP Name & Distance",
    Desc="Toggle showing item names and distance",
    Icon="bird",
    Type="Checkbox",
    Value=ESPSettings.ShowName,
    Callback=function(state) ESPSettings.ShowName=state end
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="ESP Highlight",
    Desc="Toggle highlighting items",
    Icon="star",
    Type="Checkbox",
    Value=ESPSettings.Highlight,
    Callback=function(state) ESPSettings.Highlight=state end
})

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Esp fuel",
    Icon = "fuel",
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="Fuel ESP",
    Desc="ESP for fuel/items",
    Icon="flame",
    Type="Checkbox",
    Value=ESPSettings.ShowFuel,
    Callback=function(state) ESPSettings.ShowFuel=state end
})

VisualTab:Dropdown({
    Flag = "AutoTab",
    Title="Select Fuel Types",
    Desc="Pick fuel/item types to ESP",
    Values=FuelList,
    Value=ESPSettings.SelectedFuel,
    Multi=true,
    AllowNone=true,
    Callback=function(selection) ESPSettings.SelectedFuel=selection end
})

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Esp gears",
    Icon = "cog",
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="Gears ESP",
    Desc="ESP for gears/items",
    Icon="flame",
    Type="Checkbox",
    Value=ESPSettings.ShowGears,
    Callback=function(state) ESPSettings.ShowGears=state end
})

VisualTab:Dropdown({
    Flag = "AutoTab",
    Title="Select Gears Types",
    Desc="Pick gears/item types to ESP",
    Values=GearsList,
    Value=ESPSettings.SelectedGears,
    Multi=true,
    AllowNone=true,
    Callback=function(selection) ESPSettings.SelectedGears=selection end
})

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Esp food",
    Icon = "apple",
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="Food ESP",
    Desc="ESP for food/items",
    Icon="flame",
    Type="Checkbox",
    Value=ESPSettings.ShowFood,
    Callback=function(state) ESPSettings.ShowFood=state end
})

VisualTab:Dropdown({
    Flag = "AutoTab",
    Title="Select Food Types",
    Desc="Pick food/item types to ESP",
    Values=FoodList,
    Value=ESPSettings.SelectedFood,
    Multi=true,
    AllowNone=true,
    Callback=function(selection) ESPSettings.SelectedFood=selection end
})

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Esp Weapons",
    Icon = "swords" ,
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="Weapons ESP",
    Desc="ESP for weapons/items",
    Icon="flame",
    Type="Checkbox",
    Value=ESPSettings.ShowWeapons,
    Callback=function(state) ESPSettings.ShowWeapons=state end
})

VisualTab:Dropdown({
    Flag = "AutoTab",
    Title="Select Weapons Types",
    Desc="Pick weapon types to ESP",
    Values=WeaponList,
    Value=ESPSettings.SelectedWeapons,
    Multi=true,
    AllowNone=true,
    Callback=function(selection) ESPSettings.SelectedWeapons=selection end
})

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Esp Others",
    Icon = "badge-question-mark",
})

VisualTab:Toggle({
    Flag = "AutoTab",
    Title="Others ESP",
    Desc="Toggle ESP for other items",
    Icon="flame",
    Type="Checkbox",
    Value=ESPSettings.ShowOthers,
    Callback=function(state) ESPSettings.ShowOthers=state end
})

VisualTab:Dropdown({
    Flag = "AutoTab",
    Title="Select Others Types",
    Desc="Pick other item types to ESP",
    Values=OthersList,
    Value=ESPSettings.SelectedOthers,
    Multi=true,
    AllowNone=true,
    Callback=function(selection) ESPSettings.SelectedOthers=selection end
})

-- TREE HP ESP (optimized, toggle-safe)

espFolder = Workspace:FindFirstChild("TreeHPESP") or Instance.new("Folder", Workspace)
espFolder.Name = "TreeHPESP"
espMap = espMap or {}

-- Remove ESP for a single tree
function removeESP(tree)
    local info = espMap[tree]
    if info then
        pcall(function() if info.bb and info.bb.Parent then info.bb:Destroy() end end)
        espMap[tree] = nil
    end
end

-- Remove all ESP
function removeAllESP()
    for tree,_ in pairs(espMap) do removeESP(tree) end
end

-- Update or create ESP for a tree
function updateESP(tree)
    if not SETTINGS.ShowHP then return removeESP(tree) end
    if not tree or not tree.Parent then return removeESP(tree) end

    local root = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
    if not root then return removeESP(tree) end

    local info = espMap[tree]
    if not info then
        local bb = Instance.new("BillboardGui")
        bb.Name = "AutoCut_HP"
        bb.Adornee = root
        bb.Size = UDim2.new(0,120,0,22)
        bb.StudsOffset = Vector3.new(0,2.2,0)
        bb.AlwaysOnTop = true
        bb.Parent = espFolder

        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.fromScale(1,1)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.GothamBold
        lbl.TextScaled = true
        lbl.TextColor3 = Color3.new(1,1,1)
        lbl.Parent = bb

        espMap[tree] = { bb = bb, lbl = lbl }
        info = espMap[tree]
    end

    local hp = tree:GetAttribute("Health")
    info.lbl.Text = (tree.Name or "Tree").." | HP: "..(hp and math.floor(tonumber(hp) or hp) or "N/A")
    info.bb.Enabled = SETTINGS.ShowHP
end

-- Continuously update all trees
game:GetService("RunService").RenderStepped:Connect(function()
    if not SETTINGS.ShowHP then return end
    local fol, lm = Workspace:FindFirstChild("Map") or Workspace:FindFirstChild("map")
    if fol then fol = fol:FindFirstChild("Foliage") or fol:FindFirstChild("foliage") end
    if lm then lm = lm:FindFirstChild("Landmarks") or lm:FindFirstChild("landmarks") end

    local trees = {}
    if fol then for _,t in ipairs(fol:GetChildren()) do if t:GetAttribute("Health") then table.insert(trees,t) end end end
    if lm then for _,t in ipairs(lm:GetChildren()) do if t:GetAttribute("Health") then table.insert(trees,t) end end end

    for _,t in ipairs(trees) do updateESP(t) end
end)

-- Clean up on tree removal
Workspace.DescendantRemoving:Connect(function(desc)
    if espMap[desc] then removeESP(desc) end
end)

VisualTab:Divider()

Section = VisualTab:Section({ 
    Title = "Performance",
    Icon = "circle-alert",
})

-- Remove Fog Toggle
VisualTab:Toggle({
    Flag = "AutoTab",
    Title = "Remove Fog",
    Desc = "Toggle to remove all fog",
    Icon = "eye",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        if state then
            Lighting.FogEnd = 100000
            Lighting.FogStart = 0
        else
            Lighting.FogEnd = 1000
            Lighting.FogStart = 0
        end
    end
})

-- Ultra Lower Graphics Toggle
VisualTab:Toggle({
    Flag = "AutoTab",
    Title = "Lower Graphics (Ultra)",
    Desc = "Toggle maximum performance mode (might affect your gameplay/scripts!)",
    Icon = "gear",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        -- ===== Lighting & Shadows =====
        if state then
            Lighting.GlobalShadows = false
            Lighting.QualityLevel = Enum.QualityLevel.Level1
            Lighting.FogEnd = 300
            Lighting.FogStart = 0
            Lighting.Brightness = 0.5
            Lighting.ClockTime = 14
        else
            Lighting.GlobalShadows = true
            Lighting.QualityLevel = Enum.QualityLevel.Level21
            Lighting.FogEnd = 1000
            Lighting.FogStart = 0
            Lighting.Brightness = 2
        end

        -- ===== Post-Processing =====
        for _, effect in pairs(Lighting:GetChildren()) do
            if effect:IsA("BloomEffect") or effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") or effect:IsA("SunRaysEffect") or effect:IsA("DepthOfFieldEffect") then
                effect.Enabled = not state
            end
        end

        -- ===== Particles & Trails =====
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj.Enabled = not state
                if state then
                    obj.Rate = 0
                    obj.Lifetime = NumberRange.new(0)
                end
            end
        end

        -- ===== Simplify Models =====
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part") or obj:IsA("WedgePart") or obj:IsA("CornerWedgePart") then
                if state then
                    obj.Material = Enum.Material.Plastic
                    obj.Reflectance = 0
                    obj.Transparency = math.min(obj.Transparency, 0.1)
                    obj.CastShadow = false
                else
                    obj.Material = Enum.Material.SmoothPlastic
                    obj.Reflectance = 0
                    obj.Transparency = 0
                    obj.CastShadow = true
                end
            end
        end

        -- ===== Simplify ESP / GUI =====
        if ESPObjects then
            for item, entry in pairs(ESPObjects) do
                if entry.Highlight then
                    entry.Highlight.Enabled = (ESPSettings.Highlight and not state)
                    entry.Highlight.FillTransparency = (state and 0.95 or 0.5)
                end
                if entry.Label then
                    entry.Label.TextScaled = not state
                    entry.Label.TextStrokeTransparency = (state and 1 or 0)
                end
            end
        end

        -- ===== Optional: hide far-away parts =====
        if state then
            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("BasePart") and (obj.Position - LocalPlayer.Character.PrimaryPart.Position).Magnitude > 500 then
                    obj.Transparency = 1
                end
            end
        else
            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("BasePart") then
                    obj.Transparency = 0
                end
            end
        end
    end
})

-- Full Bright Toggle
VisualTab:Toggle({
    Flag = "AutoTab",
    Title = "Full Bright",
    Desc = "I Can See Everything!",
    Icon = "sun",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        if state then
            Lighting.Ambient = Color3.fromRGB(255,255,255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255,255,255)
        else
            Lighting.Ambient = Color3.fromRGB(128,128,128)
            Lighting.OutdoorAmbient = Color3.fromRGB(128,128,128)
        end
    end
})

-- Transparent Black Screen Toggle (fixed full screen)
VisualTab:Toggle({
    Flag = "AutoTab",
    Title = "Black Screen",
    Desc = "Toggle black screen (if you're eyes are burning)",
    Icon = "moon",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        if state then
            if not Players.LocalPlayer.PlayerGui:FindFirstChild("BlackScreen") then
                overlay = Instance.new("ScreenGui")
                overlay.Name = "BlackScreen"
                overlay.ResetOnSpawn = false
                overlay.IgnoreGuiInset = true
                overlay.Parent = Players.LocalPlayer.PlayerGui

                frame = Instance.new("Frame")
                frame.Size = UDim2.fromScale(1,1)
                frame.Position = UDim2.new(0,0,0,0)
                frame.BackgroundColor3 = Color3.new(0,0,0)
                frame.BackgroundTransparency = 0.1
                frame.ZIndex = 999
                frame.Parent = overlay
            end
        else
            overlay = Players.LocalPlayer.PlayerGui:FindFirstChild("BlackScreen")
            if overlay then overlay:Destroy() end
        end
    end
})

-- Restore Graphics Button
VisualTab:Button({
    Flag = "AutoTab",
    Title = "Restore Graphics",
    Desc = "Restores default graphics settings",
    Icon = "refresh",
    Callback = function()
        -- Fog
        Lighting.FogEnd = 1000
        Lighting.FogStart = 0
        -- Graphics
        Lighting.GlobalShadows = true
        Lighting.QualityLevel = Enum.QualityLevel.Level21
        Lighting.ReflectionMode = Enum.ReflectionMode.Default
        Workspace.Terrain.WaterReflectance = 1
        Workspace.Terrain.WaterWaveSize = 1
        -- Full Bright
        Lighting.Ambient = Color3.fromRGB(128,128,128)
        Lighting.OutdoorAmbient = Color3.fromRGB(128,128,128)
        -- Black Screen
        overlay = Players.LocalPlayer.PlayerGui:FindFirstChild("BlackScreen")
        if overlay then overlay:Destroy() end
    end
})

-- üè† Main Tab
LocalPlayerTab = Window:Tab({
    Title = "LocalPlayer",
    Icon = "user",
})

Section = LocalPlayerTab:Section({ 
    Title = "Map Loader",
    Icon = "map",
})

-- ==============================
-- Grass Loader with WindUI Everywhere
-- ==============================

MAPLOADER_ACTIVE = false
LOAD_DELAY = 0.05 -- default delay

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")

-- Universal WindUI notifier
function NOTIFY(title, content, duration)
    if WindUI then
        WindUI:Notify({
            Title = title,
            Content = content,
            Duration = duration or 3,
            Icon = "rbxassetid://84501312005643",
        })
    else
        warn("[Map loader] "..title..": "..content)
    end
end

function MAPLOADER_GrassScan()
    if MAPLOADER_ACTIVE then return end
    MAPLOADER_ACTIVE = true

    plr = Players.LocalPlayer
    if not plr then return end
    char = plr.Character or plr.CharacterAdded:Wait()
    hrp = char:WaitForChild("HumanoidRootPart")

    grassFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ground")
    if not grassFolder then
        NOTIFY("GrassLoader", "No Map.Ground folder found!", 3)
        MAPLOADER_ACTIVE = false
        return
    end

    grassParts = {}
    for i, v in pairs(grassFolder:GetChildren()) do
        if v:IsA("BasePart") then
            table.insert(grassParts, v)
        end
    end

    if #grassParts == 0 then
        NOTIFY("GrassLoader", "No grass parts found!", 3)
        MAPLOADER_ACTIVE = false
        return
    end

    NOTIFY("MapLoader", "Starting teleport (Delay: "..LOAD_DELAY.."s)", 2)

    for i = 1, #grassParts do
        if not MAPLOADER_ACTIVE then break end
        part = grassParts[i]
        if part and part.Parent then
            hrp.CFrame = CFrame.new(part.Position + Vector3.new(0, 3, 0))
        end
        task.wait(LOAD_DELAY)
    end

    MAPLOADER_ACTIVE = false
    NOTIFY("Map Loader", "Finished teleporting!", 3)
end

function MAPLOADER_Stop()
    MAPLOADER_ACTIVE = false
    NOTIFY("Map Loader", "Stopped!", 2)
end

-- ==============================
-- UI Integration
-- ==============================
if LocalPlayerTab then

    LocalPlayerTab:Toggle({
    Flag = "AutoTab",
        Title = "Map Loader",
        Desc = "Force load map",
        Value = false,
        Callback = function(v)
            if v then
                task.spawn(MAPLOADER_GrassScan)
            else
                MAPLOADER_Stop()
            end
        end
    })

    LocalPlayerTab:Slider({
    Flag = "AutoTab",
        Title = "Teleport Speed",
        Desc = "Adjust teleport delay (0.01 fastest, 1 slowest)",
        Value = {
            Min = 0.01,
            Max = 1,
            Default = LOAD_DELAY,
        },
        Step = 0.01,
        Callback = function(value)
            LOAD_DELAY = value
        end
    })

else
    NOTIFY("MapLoader", "LocalPlayerTab not found; use MAPLOADER_GrassScan() / MAPLOADER_Stop() manually.", 3)
end

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
ReplicatedStorage = game:GetService("ReplicatedStorage")

function TPToCamp()
    local plr = Players.LocalPlayer
    if not plr then return end
    local char = plr.Character or plr.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")

    -- Campfire coordinates
    local targetPos = Vector3.new(4.95910645e-05, 9.5, -7.62939453e-06)
    hrp.CFrame = CFrame.new(targetPos)
end

-- ==============================
-- MainTab Buttons (No locals)
-- ==============================
if LocalPlayerTab then
    LocalPlayerTab:Button({
        Title = "TP to Campfire",
        Desc = "Teleport to campfire",
        Locked = false,
        Callback = function()
            TPToCamp()
        end
    })
end  -- <<< ADD THIS

LocalPlayerTab:Divider()

-- ==============================
-- AFK Floating Box (fixed timer, minimize, no locals)
-- ==============================

-- ensure NOTIFY exists
if not NOTIFY then
    function NOTIFY(title, content, duration)
        if WindUI then
            WindUI:Notify({
                Title = title,
                Content = content,
                Duration = duration or 3,
                Icon = "rbxassetid://84501312005643",
            })
        else
            warn("["..tostring(title).."] "..tostring(content))
        end
    end
end

-- cleanup any previous GUI
if Players and Players.LocalPlayer and Players.LocalPlayer:FindFirstChild("PlayerGui") and Players.LocalPlayer.PlayerGui:FindFirstChild("RyZenHubAFK") then
    Players.LocalPlayer.PlayerGui.RyZenHubAFK:Destroy()
end

-- globals
ANTI_AFK_ENABLED = false
ANTI_AFK_TIME = 0

AFK_GUI = nil
AFK_Frame = nil
AFK_Timer = nil
AFK_CopyBtn = nil
AFK_Close = nil
AFK_MinBtn = nil

-- dragging state
AFK_DRAGGING = false
AFK_DRAG_INPUT = nil
AFK_DRAG_OFFSET_X = 0
AFK_DRAG_OFFSET_Y = 0

-- connections & runner
AFK_CONN_INPUT_BEGAN = AFK_CONN_INPUT_BEGAN
AFK_CONN_INPUT_CHANGED = AFK_CONN_INPUT_CHANGED
AFK_CONN_INPUT_ENDED = AFK_CONN_INPUT_ENDED
ANTI_AFK_IDLED_CONN = ANTI_AFK_IDLED_CONN
ANTI_AFK_HEART_CONN = ANTI_AFK_HEART_CONN

-- other state
AFK_MINIMIZED = false

-- services
Players = game:GetService("Players")
UserInputService = game:GetService("UserInputService")
RunService = game:GetService("RunService")
VirtualUser = game:GetService("VirtualUser")
Workspace = game:GetService("Workspace")

-- helper: format seconds to HH:MM:SS
function FORMAT_TIME(seconds)
    h = math.floor(seconds / 3600)
    m = math.floor((seconds % 3600) / 60)
    s = seconds % 60
    return string.format("%02d:%02d:%02d", h, m, s)
end

-- create GUI (idempotent)
function CREATE_AFK_GUI()
    if AFK_GUI and AFK_GUI.Parent then return end

    -- destroy old if present
    if Players.LocalPlayer.PlayerGui:FindFirstChild("RyZenHubAFK") then
        Players.LocalPlayer.PlayerGui.RyZenHubAFK:Destroy()
    end

    AFK_GUI = Instance.new("ScreenGui")
    AFK_GUI.Name = "RyZenHubAFK"
    AFK_GUI.ResetOnSpawn = false
    AFK_GUI.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

    AFK_Frame = Instance.new("Frame")
    AFK_Frame.Name = "AFKFrame"
    AFK_Frame.Size = UDim2.new(0, 240, 0, 100)
    AFK_Frame.Position = UDim2.new(0.7, 0, 0.08, 0) -- inset from edge
    AFK_Frame.BackgroundTransparency = 0
    AFK_Frame.BorderSizePixel = 0
    AFK_Frame.Parent = AFK_GUI

    AFK_Gradient = Instance.new("UIGradient")
    AFK_Gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 30, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    }
    AFK_Gradient.Rotation = 45
    AFK_Gradient.Parent = AFK_Frame

    AFK_Round = Instance.new("UICorner")
    AFK_Round.CornerRadius = UDim.new(0, 10)
    AFK_Round.Parent = AFK_Frame

    AFK_Title = Instance.new("TextLabel")
    AFK_Title.Name = "Title"
    AFK_Title.Size = UDim2.new(1, -80, 0, 24)
    AFK_Title.Position = UDim2.new(0, 10, 0, 6)
    AFK_Title.BackgroundTransparency = 1
    AFK_Title.Text = "RyZen Hub AFK"
    AFK_Title.TextColor3 = Color3.fromRGB(200, 230, 255)
    AFK_Title.Font = Enum.Font.SourceSansBold
    AFK_Title.TextSize = 16
    AFK_Title.TextXAlignment = Enum.TextXAlignment.Left
    AFK_Title.Parent = AFK_Frame

    AFK_Timer = Instance.new("TextLabel")
    AFK_Timer.Name = "Timer"
    AFK_Timer.Size = UDim2.new(0, 140, 0, 36)
    AFK_Timer.Position = UDim2.new(0, 50, 0, 32)
    AFK_Timer.BackgroundTransparency = 1
    AFK_Timer.Text = FORMAT_TIME(ANTI_AFK_TIME)
    AFK_Timer.TextColor3 = Color3.fromRGB(230, 250, 255)
    AFK_Timer.Font = Enum.Font.SourceSansBold
    AFK_Timer.TextSize = 22
    AFK_Timer.TextXAlignment = Enum.TextXAlignment.Center
    AFK_Timer.Parent = AFK_Frame

    AFK_CopyBtn = Instance.new("TextButton")
    AFK_CopyBtn.Name = "CopyButton"
    AFK_CopyBtn.Size = UDim2.new(0, 90, 0, 26)
    AFK_CopyBtn.Position = UDim2.new(1, -10, 1, -10) -- bottom-right inside frame
    AFK_CopyBtn.AnchorPoint = Vector2.new(1, 1)
    AFK_CopyBtn.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
    AFK_CopyBtn.BorderSizePixel = 0
    AFK_CopyBtn.Text = "Copy Time"
    AFK_CopyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    AFK_CopyBtn.Font = Enum.Font.SourceSansBold
    AFK_CopyBtn.TextSize = 14
    AFK_CopyBtn.Parent = AFK_Frame

    AFK_MinBtn = Instance.new("TextButton")
    AFK_MinBtn.Name = "MinBtn"
    AFK_MinBtn.Size = UDim2.new(0, 26, 0, 22)
    AFK_MinBtn.Position = UDim2.new(1, -56, 0, 6)
    AFK_MinBtn.BackgroundTransparency = 0.5
    AFK_MinBtn.BackgroundColor3 = Color3.fromRGB(20,20,20)
    AFK_MinBtn.Text = "_"
    AFK_MinBtn.TextColor3 = Color3.fromRGB(255,255,255)
    AFK_MinBtn.Font = Enum.Font.SourceSansBold
    AFK_MinBtn.TextSize = 18
    AFK_MinBtn.Parent = AFK_Frame

    AFK_Close = Instance.new("TextButton")
    AFK_Close.Name = "CloseBtn"
    AFK_Close.Size = UDim2.new(0, 22, 0, 22)
    AFK_Close.Position = UDim2.new(1, -28, 0, 6)
    AFK_Close.BackgroundTransparency = 0.5
    AFK_Close.BackgroundColor3 = Color3.fromRGB(20,20,20)
    AFK_Close.Text = "X"
    AFK_Close.TextColor3 = Color3.fromRGB(255,255,255)
    AFK_Close.Font = Enum.Font.SourceSansBold
    AFK_Close.TextSize = 14
    AFK_Close.Parent = AFK_Frame

    -- copy behavior
    AFK_CopyBtn.MouseButton1Click:Connect(function()
        pcall(function()
            setclipboard(FORMAT_TIME(ANTI_AFK_TIME))
            NOTIFY("Anti-AFK", "Copied "..FORMAT_TIME(ANTI_AFK_TIME).." to clipboard!", 2)
        end)
    end)

    -- close behavior (destroy GUI and disable)
    AFK_Close.MouseButton1Click:Connect(function()
        ANTI_AFK_ENABLED = false
        DESTROY_AFK_GUI()
        NOTIFY("Anti-AFK", "Disabled and UI removed", 2)
    end)

    -- minimize behavior (toggle)
    AFK_MinBtn.MouseButton1Click:Connect(function()
        AFK_MINIMIZED = not AFK_MINIMIZED
        if AFK_MINIMIZED then
            -- shrink to small bar
            AFK_Frame.Size = UDim2.new(0, 160, 0, 34)
            AFK_Timer.Visible = false
            AFK_CopyBtn.Visible = false
            AFK_Title.Text = "RyZen Hub AFK (min)"
        else
            AFK_Frame.Size = UDim2.new(0, 240, 0, 100)
            AFK_Timer.Visible = true
            AFK_CopyBtn.Visible = true
            AFK_Title.Text = "RyZen Hub AFK"
        end
    end)

    -- InputBegan: start drag on MouseButton1 or Touch
    AFK_CONN_INPUT_BEGAN = AFK_Frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            AFK_DRAGGING = true
            AFK_DRAG_INPUT = input
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                pos = UserInputService:GetMouseLocation()
            else
                pos = input.Position
            end
            AFK_DRAG_OFFSET_X = pos.X - AFK_Frame.AbsolutePosition.X
            AFK_DRAG_OFFSET_Y = pos.Y - AFK_Frame.AbsolutePosition.Y
        end
    end)

    -- InputChanged: update position for both mouse movement & touch move
    AFK_CONN_INPUT_CHANGED = UserInputService.InputChanged:Connect(function(input)
        if AFK_DRAGGING and AFK_DRAG_INPUT then
            -- accept movement events
            if input == AFK_DRAG_INPUT or input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.MouseButton1 then
                    pos = UserInputService:GetMouseLocation()
                else
                    pos = input.Position
                end
                newX = pos.X - AFK_DRAG_OFFSET_X
                newY = pos.Y - AFK_DRAG_OFFSET_Y
                -- clamp inside screen
                cam = Workspace.CurrentCamera
                if cam then
                    vs = cam.ViewportSize
                    if newX < 0 then newX = 0 end
                    if newY < 0 then newY = 0 end
                    maxX = vs.X - AFK_Frame.AbsoluteSize.X
                    maxY = vs.Y - AFK_Frame.AbsoluteSize.Y
                    if newX > maxX then newX = maxX end
                    if newY > maxY then newY = maxY end
                end
                AFK_Frame.Position = UDim2.new(0, newX, 0, newY)
            end
        end
    end)

    -- InputEnded: stop dragging when the same input ends
    AFK_CONN_INPUT_ENDED = AFK_Frame.InputEnded:Connect(function(input)
        if AFK_DRAG_INPUT and input == AFK_DRAG_INPUT then
            AFK_DRAGGING = false
            AFK_DRAG_INPUT = nil
        end
    end)

    AFK_GUI.Enabled = true
end

-- destroy GUI and disconnect handlers
function DESTROY_AFK_GUI()
    if AFK_CONN_INPUT_CHANGED then
        AFK_CONN_INPUT_CHANGED:Disconnect()
        AFK_CONN_INPUT_CHANGED = nil
    end
    if AFK_CONN_INPUT_ENDED then
        AFK_CONN_INPUT_ENDED:Disconnect()
        AFK_CONN_INPUT_ENDED = nil
    end
    if AFK_CONN_INPUT_BEGAN then
        AFK_CONN_INPUT_BEGAN:Disconnect()
        AFK_CONN_INPUT_BEGAN = nil
    end
    if AFK_GUI and AFK_GUI.Parent then
        AFK_GUI:Destroy()
    end
    AFK_GUI = nil
    AFK_Frame = nil
    AFK_Timer = nil
    AFK_CopyBtn = nil
    AFK_Close = nil
    AFK_MinBtn = nil
    AFK_DRAGGING = false
    AFK_DRAG_INPUT = nil

    -- stop heartbeat timer if running
    if ANTI_AFK_HEART_CONN then
        ANTI_AFK_HEART_CONN:Disconnect()
        ANTI_AFK_HEART_CONN = nil
    end
end

-- single idled handler to prevent kicks (if not already connected)
if not ANTI_AFK_IDLED_CONN then
    ANTI_AFK_IDLED_CONN = Players.LocalPlayer.Idled:Connect(function()
        if ANTI_AFK_ENABLED then
            VirtualUser:CaptureController()
            VirtualUser:ClickButton1(Vector2.new(0,0))
        end
    end)
end

-- timer runner using RunService.Heartbeat (one connection only)
function START_AFK_TIMER_LOOP()
    if ANTI_AFK_HEART_CONN then return end
    -- ensure AFK_Timer text exists and time is correct
    if AFK_Timer then AFK_Timer.Text = FORMAT_TIME(ANTI_AFK_TIME) end
    accumulator = 0
    ANTI_AFK_HEART_CONN = RunService.Heartbeat:Connect(function(dt)
        if not ANTI_AFK_ENABLED then return end
        accumulator = accumulator + dt
        while accumulator >= 1 do
            accumulator = accumulator - 1
            ANTI_AFK_TIME = ANTI_AFK_TIME + 1
            if AFK_Timer then AFK_Timer.Text = FORMAT_TIME(ANTI_AFK_TIME) end
        end
    end)
end

function STOP_AFK_TIMER_LOOP()
    if ANTI_AFK_HEART_CONN then
        ANTI_AFK_HEART_CONN:Disconnect()
        ANTI_AFK_HEART_CONN = nil
    end
end

-- toggle integration (create/destroy GUI and start/stop timers)
if LocalPlayerTab then
    LocalPlayerTab:Toggle({
    Flag = "AutoTab",
        Title = "Anti-AFK",
        Desc = "Avoid being kicked while afk",
        Default = false,
        Callback = function(state)
            ANTI_AFK_ENABLED = state
            if ANTI_AFK_ENABLED then
                ANTI_AFK_TIME = 0
                CREATE_AFK_GUI()
                START_AFK_TIMER_LOOP()
                NOTIFY("Anti-AFK", "Enabled", 2)
            else
                ANTI_AFK_ENABLED = false
                STOP_AFK_TIMER_LOOP()
                DESTROY_AFK_GUI()
                NOTIFY("Anti-AFK", "Disabled and UI removed", 2)
            end
        end
    })
else
    NOTIFY("Anti-AFK", "Tab not found ‚Äî set ANTI_AFK_ENABLED = true to enable", 3)
end

-- ==============================
-- Freeze Character Toggle (no notifications)
-- ==============================
if LocalPlayerTab then
    LocalPlayerTab:Toggle({
    Flag = "AutoTab",
        Title = "Freeze Character",
        Desc = "Freeze/unfreeze your character in place",
        Default = false,
        Callback = function(state)
            plr = game:GetService("Players").LocalPlayer
            if not plr then return end
            char = plr.Character or plr.CharacterAdded:Wait()
            hrp = char:WaitForChild("HumanoidRootPart")
            humanoid = char:FindFirstChildOfClass("Humanoid")
            
            if state then
                -- Freeze
                hrp.Anchored = true
                if humanoid then humanoid.PlatformStand = true end
            else
                -- Unfreeze
                hrp.Anchored = false
                if humanoid then humanoid.PlatformStand = false end
            end
        end
    })
end

LocalPlayerTab:Divider()

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local humanoid

local DESIRED_SPEED = 16
local SpeedEnabled = false  -- toggle

local function applySpeed()
    if SpeedEnabled and humanoid then
        if humanoid.WalkSpeed ~= DESIRED_SPEED then
            humanoid.WalkSpeed = DESIRED_SPEED
        end
    end
end

-- --- Toggle Button ---
LocalPlayerTab:Toggle({
    Title = "Walk Speed",
    Default = false,
    Callback = function(state)
        SpeedEnabled = state

        if SpeedEnabled then
            applySpeed()
        else
            if humanoid then
                humanoid.WalkSpeed = 16  -- default
            end
        end
    end
})

-- --- Slider ---
LocalPlayerTab:Slider({
    Title = "Walk Speed Value",
    Desc = "Choose your walk speed",
    Step = 1,
    Value = {Min = 16, Max = 200, Default = 16},
    Callback = function(value)
        DESIRED_SPEED = value
        applySpeed()
    end
})

-- Character added handler
plr.CharacterAdded:Connect(function(char)
    humanoid = char:WaitForChild("Humanoid")

    -- Enforce speed ONLY when game tries to change it
    humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        applySpeed()
    end)

    applySpeed()
end)

-- If character already exists
if plr.Character then
    humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(applySpeed)
        applySpeed()
    end
end

LocalPlayerTab:Space()

-- Infinite Jump Toggle
LocalPlayerTab:Toggle({
    Flag = "AutoTab",
    Title = "Infinite Jump",
    Desc = "you can go to heaven with this!",
    Default = false,
    Callback = function(state)
        INFINITE_JUMP = state
    end
})

-- no locals: listen for jump
game:GetService("UserInputService").JumpRequest:Connect(function()
    if INFINITE_JUMP then
        plr = game:GetService("Players").LocalPlayer
        if plr and plr.Character then
            humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
end)

LocalPlayerTab:Space()

-- Noclip Toggle
LocalPlayerTab:Toggle({
    Flag = "AutoTab",
    Title = "No Clip",
    Desc = "Walk through walls",
    Default = false,
    Callback = function(state)
        NOCLIP_ENABLED = state
    end
})

-- RunService loop to apply noclip
game:GetService("RunService").Stepped:Connect(function()
    if NOCLIP_ENABLED then
        plr = game:GetService("Players").LocalPlayer
        if plr and plr.Character then
            for _, part in pairs(plr.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end
end)

LocalPlayerTab:Space()

-- SPIN (BodyAngularVelocity, degrees-per-second, FPS-independent)
Players = game:GetService("Players")
RunService = game:GetService("RunService")

SPIN_ENABLED = SPIN_ENABLED or false          -- controlled by the tab toggle
SPIN_SPEED   = SPIN_SPEED   or 200            -- degrees per second (user-facing)
SPIN_MULTIPLIER = SPIN_MULTIPLIER or 1       -- optional multiplier if you want extra punch
plr = Players.LocalPlayer

-- runtime refs / state (globals)
hrp = nil
hum = nil
SPIN_BAV = SPIN_BAV or nil                    -- BodyAngularVelocity instance
SPIN_PREV_AUTOROTATE = SPIN_PREV_AUTOROTATE or nil
_SPIN_LAST_SPEED = _SPIN_LAST_SPEED or nil

-- refresh references to current character parts
function SPIN_UPDATE_REFS()
    if plr and plr.Character then
        hrp = plr.Character:FindFirstChild("HumanoidRootPart")
        hum = plr.Character:FindFirstChildOfClass("Humanoid")
    else
        hrp = nil
        hum = nil
    end
end

SPIN_UPDATE_REFS()
plr.CharacterAdded:Connect(function()
    task.wait(0.12)
    SPIN_UPDATE_REFS()
end)

-- create BodyAngularVelocity on the HRP
function SPIN_CREATE_BAV()
    if not hrp then return end
    if SPIN_BAV and SPIN_BAV.Parent == hrp then return end
    if SPIN_BAV then
        pcall(function() SPIN_BAV:Destroy() end)
        SPIN_BAV = nil
    end
    SPIN_BAV = Instance.new("BodyAngularVelocity")
    SPIN_BAV.Name = "RyZen_Spin_BAV"
    SPIN_BAV.MaxTorque = Vector3.new(0, 9e9, 0) -- huge torque on Y only
    -- AngularVelocity is in radians/sec
    SPIN_BAV.AngularVelocity = Vector3.new(0, math.rad(math.clamp((SPIN_SPEED or 200) * (SPIN_MULTIPLIER or 1), 0, 360000)), 0)
    SPIN_BAV.Parent = hrp
    _SPIN_LAST_SPEED = SPIN_SPEED
end

-- destroy BAV safely
function SPIN_DESTROY_BAV()
    if SPIN_BAV then
        pcall(function() SPIN_BAV:Destroy() end)
        SPIN_BAV = nil
    end
    _SPIN_LAST_SPEED = nil
end

-- TAB toggle (wires the UI toggle to SPIN_ENABLED)
LocalPlayerTab:Toggle({
    Flag = "AutoTab",
    Title = "Spin",
    Desc = "Enable character spinning",
    Default = SPIN_ENABLED,
    Callback = function(state)
        SPIN_ENABLED = state
        -- backend loop will handle creating/destroying BAV & autorotate
    end
})

-- Slider: degrees per second. Increase Max if you want insane speeds.
LocalPlayerTab:Slider({
    Flag = "AutoTab",
    Title = "Spin Speed",
    Desc = "max to become a helicopter.",
    Value = {
        Min = 10,
        Max = 2000,
        Default = SPIN_SPEED
    },
    Step = 1,
    Callback = function(value)
        SPIN_SPEED = math.max(0, value)
        -- update existing BAV immediately if present
        if SPIN_BAV and SPIN_BAV.Parent then
            SPIN_BAV.AngularVelocity = Vector3.new(0, math.rad(math.clamp(SPIN_SPEED * (SPIN_MULTIPLIER or 1), 0, 360000)), 0)
            _SPIN_LAST_SPEED = SPIN_SPEED
        end
    end
})

-- Heartbeat: manage BAV & Humanoid.AutoRotate robustly
RunService.Heartbeat:Connect(function()
    if not hrp or not hum then SPIN_UPDATE_REFS() end

    if SPIN_ENABLED then
        -- need valid humanoid & hrp to spin
        if hum and hrp then
            -- store previous AutoRotate once and disable it so Humanoid won't fight BAV
            if SPIN_PREV_AUTOROTATE == nil then
                SPIN_PREV_AUTOROTATE = hum.AutoRotate
            end
            pcall(function() hum.AutoRotate = false end)

            -- create BAV if missing or attached to old HRP
            if not SPIN_BAV or SPIN_BAV.Parent ~= hrp then
                SPIN_CREATE_BAV()
            end

            -- update angular velocity if speed changed
            if SPIN_BAV and (_SPIN_LAST_SPEED ~= SPIN_SPEED) then
                SPIN_BAV.AngularVelocity = Vector3.new(0, math.rad(math.clamp(SPIN_SPEED * (SPIN_MULTIPLIER or 1), 0, 360000)), 0)
                _SPIN_LAST_SPEED = SPIN_SPEED
            end
        else
            -- character missing; ensure no leftover BAV
            SPIN_DESTROY_BAV()
        end
    else
        -- disabled: restore AutoRotate once, remove BAV
        if hum and SPIN_PREV_AUTOROTATE ~= nil then
            pcall(function() hum.AutoRotate = SPIN_PREV_AUTOROTATE end)
            SPIN_PREV_AUTOROTATE = nil
        end
        SPIN_DESTROY_BAV()
    end
end)

-- ensure BAV recreated/destroyed properly on respawn
Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.12)
    SPIN_UPDATE_REFS()
    if SPIN_ENABLED then
        SPIN_CREATE_BAV()
    else
        SPIN_DESTROY_BAV()
    end
end)

LocalPlayerTab:Space()

Players = game:GetService("Players")
UserInputService = game:GetService("UserInputService")
RunService = game:GetService("RunService")
Workspace = game:GetService("Workspace")

-- remove any old GUI
if Players.LocalPlayer:FindFirstChild("PlayerGui") and Players.LocalPlayer.PlayerGui:FindFirstChild("RyZenFlyGUI") then
    Players.LocalPlayer.PlayerGui.RyZenFlyGUI:Destroy()
end

FLY_GUI = Instance.new("ScreenGui")
FLY_GUI.Name = "RyZenFlyGUI"
FLY_GUI.ResetOnSpawn = false
FLY_GUI.Enabled = false -- hidden by default
FLY_GUI.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

FLY_Frame = Instance.new("Frame")
FLY_Frame.Name = "FlyFrame"
FLY_Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
FLY_Frame.BackgroundTransparency = 0.2
FLY_Frame.BorderSizePixel = 0
FLY_Frame.Position = UDim2.new(0.7, 0, 0.15, 0)
FLY_Frame.Size = UDim2.new(0, 250, 0, 150)
FLY_Frame.Parent = FLY_GUI

FLY_ORIG_SIZE = FLY_Frame.Size

FLY_Corner = Instance.new("UICorner")
FLY_Corner.CornerRadius = UDim.new(0, 12)
FLY_Corner.Parent = FLY_Frame

FLY_Gradient = Instance.new("UIGradient")
FLY_Gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 30, 70)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
}
FLY_Gradient.Rotation = 45
FLY_Gradient.Parent = FLY_Frame

FLY_Title = Instance.new("TextLabel")
FLY_Title.Name = "Title"
FLY_Title.Size = UDim2.new(1, -80, 0, 26)
FLY_Title.Position = UDim2.new(0, 10, 0, 5)
FLY_Title.BackgroundTransparency = 1
FLY_Title.TextColor3 = Color3.fromRGB(200, 230, 255)
FLY_Title.Font = Enum.Font.SourceSansBold
FLY_Title.TextSize = 18
FLY_Title.TextXAlignment = Enum.TextXAlignment.Left
FLY_Title.Text = "RyZen Hub (fly)"
FLY_Title.Parent = FLY_Frame

FLY_SpeedLabel = Instance.new("TextLabel")
FLY_SpeedLabel.Name = "SpeedLabel"
FLY_SpeedLabel.Position = UDim2.new(0, 10, 0, 40)
FLY_SpeedLabel.Size = UDim2.new(0, 120, 0, 26)
FLY_SpeedLabel.BackgroundTransparency = 1
FLY_SpeedLabel.Text = "Speed: 50"
FLY_SpeedLabel.TextColor3 = Color3.fromRGB(220, 240, 255)
FLY_SpeedLabel.Font = Enum.Font.SourceSansBold
FLY_SpeedLabel.TextSize = 16
FLY_SpeedLabel.Parent = FLY_Frame

FLY_SpeedPlus = Instance.new("TextButton")
FLY_SpeedPlus.Name = "SpeedPlus"
FLY_SpeedPlus.Position = UDim2.new(0, 140, 0, 40)
FLY_SpeedPlus.Size = UDim2.new(0, 40, 0, 26)
FLY_SpeedPlus.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
FLY_SpeedPlus.BorderSizePixel = 0
FLY_SpeedPlus.Text = "+"
FLY_SpeedPlus.TextColor3 = Color3.fromRGB(255,255,255)
FLY_SpeedPlus.Font = Enum.Font.SourceSansBold
FLY_SpeedPlus.TextSize = 18
FLY_SpeedPlus.Parent = FLY_Frame

FLY_SpeedMinus = Instance.new("TextButton")
FLY_SpeedMinus.Name = "SpeedMinus"
FLY_SpeedMinus.Position = UDim2.new(0, 190, 0, 40)
FLY_SpeedMinus.Size = UDim2.new(0, 40, 0, 26)
FLY_SpeedMinus.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
FLY_SpeedMinus.BorderSizePixel = 0
FLY_SpeedMinus.Text = "-"
FLY_SpeedMinus.TextColor3 = Color3.fromRGB(255,255,255)
FLY_SpeedMinus.Font = Enum.Font.SourceSansBold
FLY_SpeedMinus.TextSize = 18
FLY_SpeedMinus.Parent = FLY_Frame

-- ON/OFF button inside GUI
FLY_OnOff = Instance.new("TextButton")
FLY_OnOff.Name = "FlyToggle"
FLY_OnOff.Position = UDim2.new(0, 10, 0, 80)
FLY_OnOff.Size = UDim2.new(0, 220, 0, 32)
FLY_OnOff.BackgroundColor3 = Color3.fromRGB(0, 160, 80) -- OFF color initially
FLY_OnOff.BorderSizePixel = 0
FLY_OnOff.Text = "Fly: OFF"
FLY_OnOff.TextColor3 = Color3.fromRGB(255,255,255)
FLY_OnOff.Font = Enum.Font.SourceSansBold
FLY_OnOff.TextSize = 18
FLY_OnOff.Parent = FLY_Frame

FLY_Close = Instance.new("TextButton")
FLY_Close.Name = "CloseBtn"
FLY_Close.Size = UDim2.new(0, 24, 0, 24)
FLY_Close.Position = UDim2.new(1, -28, 0, 6)
FLY_Close.BackgroundColor3 = Color3.fromRGB(20,20,20)
FLY_Close.BackgroundTransparency = 0.4
FLY_Close.BorderSizePixel = 0
FLY_Close.Text = "X"
FLY_Close.TextColor3 = Color3.fromRGB(255,255,255)
FLY_Close.Font = Enum.Font.SourceSansBold
FLY_Close.TextSize = 14
FLY_Close.Parent = FLY_Frame

FLY_Min = Instance.new("TextButton")
FLY_Min.Name = "MinBtn"
FLY_Min.Size = UDim2.new(0, 26, 0, 24)
FLY_Min.Position = UDim2.new(1, -56, 0, 6)
FLY_Min.BackgroundColor3 = Color3.fromRGB(20,20,20)
FLY_Min.BackgroundTransparency = 0.4
FLY_Min.BorderSizePixel = 0
FLY_Min.Text = "_"
FLY_Min.TextColor3 = Color3.fromRGB(255,255,255)
FLY_Min.Font = Enum.Font.SourceSansBold
FLY_Min.TextSize = 20
FLY_Min.Parent = FLY_Frame

FLY_UpBtn = Instance.new("TextButton")
FLY_UpBtn.Name = "UpBtn"
FLY_UpBtn.Position = UDim2.new(0,10,0,120)
FLY_UpBtn.Size = UDim2.new(0,100,0,26)
FLY_UpBtn.BackgroundColor3 = Color3.fromRGB(0,100,200)
FLY_UpBtn.Text = "UP"
FLY_UpBtn.TextColor3 = Color3.fromRGB(255,255,255)
FLY_UpBtn.Font = Enum.Font.SourceSansBold
FLY_UpBtn.TextSize = 16
FLY_UpBtn.Parent = FLY_Frame

FLY_DownBtn = Instance.new("TextButton")
FLY_DownBtn.Name = "DownBtn"
FLY_DownBtn.Position = UDim2.new(0,130,0,120)
FLY_DownBtn.Size = UDim2.new(0,100,0,26)
FLY_DownBtn.BackgroundColor3 = Color3.fromRGB(0,100,200)
FLY_DownBtn.Text = "DOWN"
FLY_DownBtn.TextColor3 = Color3.fromRGB(255,255,255)
FLY_DownBtn.Font = Enum.Font.SourceSansBold
FLY_DownBtn.TextSize = 16
FLY_DownBtn.Parent = FLY_Frame

FLY_SPEED = 50
FLY_ENABLED = false
FLY_MINIMIZED = false
FLY_UP = false
FLY_DOWN = false
FLY_DEFAULT_WALKSPEED = 16
FLY_VERT_BV = nil

-- speed buttons
FLY_SpeedPlus.MouseButton1Click:Connect(function()
    FLY_SPEED = math.min(500, FLY_SPEED + 5)
    FLY_SpeedLabel.Text = "Speed: "..FLY_SPEED
    if FLY_ENABLED and Players.LocalPlayer.Character then
        Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = FLY_SPEED
    end
end)

FLY_SpeedMinus.MouseButton1Click:Connect(function()
    FLY_SPEED = math.max(1, FLY_SPEED - 5)
    FLY_SpeedLabel.Text = "Speed: "..FLY_SPEED
    if FLY_ENABLED and Players.LocalPlayer.Character then
        Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = FLY_SPEED
    end
end)

-- GUI On/Off button
FLY_OnOff.MouseButton1Click:Connect(function()
    FLY_ENABLED = not FLY_ENABLED
    if FLY_ENABLED then
        FLY_OnOff.Text = "Fly: ON"
        FLY_OnOff.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
    else
        FLY_OnOff.Text = "Fly: OFF"
        FLY_OnOff.BackgroundColor3 = Color3.fromRGB(0, 160, 80)
    end
end)

FLY_Close.MouseButton1Click:Connect(function()
    FLY_GUI.Enabled = false
end)

FLY_Min.MouseButton1Click:Connect(function()
    FLY_MINIMIZED = not FLY_MINIMIZED
    if FLY_MINIMIZED then
        FLY_Frame.Size = UDim2.new(0,160,0,34)
        for _, child in pairs(FLY_Frame:GetChildren()) do
            if child:IsA("GuiObject") and child ~= FLY_Min and child ~= FLY_Close and child ~= FLY_Title then
                child.Visible = false
            end
        end
        FLY_Title.Text = "RyZen Fly (min)"
    else
        FLY_Frame.Size = FLY_ORIG_SIZE
        for _, child in pairs(FLY_Frame:GetChildren()) do
            if child:IsA("GuiObject") and child ~= FLY_Min and child ~= FLY_Close then
                child.Visible = true
            end
        end
        FLY_Title.Text = "RyZen Fly"
    end
end)

FLY_UpBtn.MouseButton1Down:Connect(function() FLY_UP = true end)
FLY_UpBtn.MouseButton1Up:Connect(function() FLY_UP = false end)
FLY_UpBtn.MouseLeave:Connect(function() FLY_UP = false end)
FLY_DownBtn.MouseButton1Down:Connect(function() FLY_DOWN = true end)
FLY_DownBtn.MouseButton1Up:Connect(function() FLY_DOWN = false end)
FLY_DownBtn.MouseLeave:Connect(function() FLY_DOWN = false end)

FLY_DRAGGING = false
FLY_DRAG_INPUT = nil
FLY_DRAG_START = nil
FLY_START_POS = nil

-- Input began
FLY_Frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        FLY_DRAGGING = true
        FLY_DRAG_INPUT = input
        FLY_START_POS = FLY_Frame.Position
        FLY_DRAG_START = (input.UserInputType == Enum.UserInputType.MouseButton1) 
            and UserInputService:GetMouseLocation() 
            or input.Position
    end
end)

-- Input ended
FLY_Frame.InputEnded:Connect(function(input)
    if input == FLY_DRAG_INPUT then
        FLY_DRAGGING = false
        FLY_DRAG_INPUT = nil
    end
end)

-- Input changed
UserInputService.InputChanged:Connect(function(input)
    if not FLY_DRAGGING then return end
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        local pos = (input.UserInputType == Enum.UserInputType.MouseMovement) and UserInputService:GetMouseLocation() or input.Position
        local delta = pos - FLY_DRAG_START
        FLY_Frame.Position = UDim2.new(
            FLY_START_POS.X.Scale,
            FLY_START_POS.X.Offset + delta.X,
            FLY_START_POS.Y.Scale,
            FLY_START_POS.Y.Offset + delta.Y
        )
    end
end)

-- Heartbeat fly behavior
RunService.Heartbeat:Connect(function()
    if FLY_ENABLED and Players.LocalPlayer.Character then
        local char = Players.LocalPlayer.Character
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            if FLY_DEFAULT_WALKSPEED == nil then FLY_DEFAULT_WALKSPEED = hum.WalkSpeed end
            hum.WalkSpeed = FLY_SPEED
        end
        if hrp then
            if not FLY_VERT_BV or FLY_VERT_BV.Parent ~= hrp then
                if FLY_VERT_BV then pcall(function() FLY_VERT_BV:Destroy() end) end
                FLY_VERT_BV = Instance.new("BodyVelocity")
                FLY_VERT_BV.Name = "RyZenFly_VertBV"
                FLY_VERT_BV.MaxForce = Vector3.new(0,1e5,0)
                FLY_VERT_BV.Velocity = Vector3.new(0,0,0)
                FLY_VERT_BV.P = 1250
                FLY_VERT_BV.Parent = hrp
            end
            local velY = 0
            if FLY_UP then velY = FLY_SPEED end
            if FLY_DOWN then velY = -FLY_SPEED end
            FLY_VERT_BV.Velocity = Vector3.new(0, velY, 0)
        end
    else
        if FLY_VERT_BV then pcall(function() FLY_VERT_BV:Destroy() end) FLY_VERT_BV = nil end
        if Players.LocalPlayer.Character then
            local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum.WalkSpeed = FLY_DEFAULT_WALKSPEED or 16 end
        end
    end
end)

Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    if FLY_ENABLED then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum and FLY_DEFAULT_WALKSPEED == nil then FLY_DEFAULT_WALKSPEED = hum.WalkSpeed end
        if hum then hum.WalkSpeed = FLY_SPEED end
        if hrp then
            if FLY_VERT_BV then pcall(function() FLY_VERT_BV:Destroy() end) end
            FLY_VERT_BV = Instance.new("BodyVelocity")
            FLY_VERT_BV.Name = "RyZenFly_VertBV"
            FLY_VERT_BV.MaxForce = Vector3.new(0,1e5,0)
            FLY_VERT_BV.Velocity = Vector3.new(0,0,0)
            FLY_VERT_BV.P = 1250
            FLY_VERT_BV.Parent = hrp
        end
    else
        if FLY_VERT_BV then pcall(function() FLY_VERT_BV:Destroy() end) FLY_VERT_BV = nil end
    end
end)

-- TAB toggle only shows/hides GUI
LocalPlayerTab:Toggle({
    Flag = "AutoTab",
    Title = "Fly",
    Desc = "be able to fly",
    Default = false,
    Callback = function(state)
        FLY_GUI.Enabled = state
    end
})

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "compass", -- optional
    Locked = false,
})

MiscTab:Section({
    Title = "Themes",
    Desc = "Select Your Themes.",
    Color = "Blue"
})

-- üé® Theme Dropdown
MiscTab:Dropdown({
    Flag = "AutoTab",
    Title = "Select Theme",
    Values = themeNames,
    Value = "Volcano",
    Callback = function(selectedTheme)
        WindUI:SetTheme(selectedTheme)
    end
})

-- ü™ü Transparent Window Toggle
MiscTab:Toggle({
    Flag = "AutoTab",
    Title = "Transparent Window",
    Desc = "Toggle UI transparency on or off",
    Default = false, -- starts off
    Callback = function(state)
        if state then
            Window:ToggleTransparency(true)
        else
            Window:ToggleTransparency(false)
        end
    end
})

MiscTab:Divider()

local Section = MiscTab:Section({
    Title = "Configs (COMING SOON)",
    Icon = "folder-dot",
})

